2.  how do you do the debug?
    I personally like using the System.out.println() to to the debug more,
    but if I can not solve it by using that way I will just use the breakpoint
3.  What is DTO, VO, Payload, DO, model?
    DTO (Data Transfer Object):
    DTO stands for Data Transfer Object. It is a design pattern used to transfer data between different layers or components of an application, often used in distributed systems and web services. DTOs are simple objects that only contain fields and accessor methods to get and set the data. They are used to encapsulate data and send it over the network efficiently, helping to reduce the number of remote calls and improving performance.

VO (Value Object):
VO stands for Value Object. It is another design pattern used to represent objects whose equality is based on the value of their attributes rather than their identity. In other words, Value Objects are immutable objects that do not have a unique identifier and are used for modeling concepts that are identified by their attributes rather than a database ID. For example, a Date Range object can be considered a Value Object.

Payload:
In the context of web development and APIs, the term "payload" refers to the data being transmitted in a request or response. It usually contains the actual data that needs to be processed, created, or updated by the server. In RESTful API design, the payload is typically represented in JSON or XML format and is sent in the body of the HTTP request.

DO (Domain Object):
DO stands for Domain Object. It represents an object in the business domain of an application. Domain Objects encapsulate the core business logic and behavior of the application and are used to model real-world entities and their relationships. These objects are typically part of the domain layer of the application and interact with the data access layer (DAO or Repository) to persist or retrieve data.

Model:
The term "Model" is a broader concept that refers to the overall data representation used in an application. It can encompass various types of objects like Domain Objects (DO), Data Transfer Objects (DTO), Value Objects (VO), and even database entities. The Model represents the structure and behavior of the data in the application, providing a way to interact with the data and manage its state.
4.  What is @JsonProperty("description_yyds") (不会的话，课上问)?
    @JsonProperty is an annotation used in Java frameworks, particularly in the context of serializing and deserializing JSON data. It is commonly used with libraries like Jackson, GSON, or other JSON processing libraries in Java.
    When you have a Java class that needs to be converted to JSON (serialization) or JSON data that needs to be converted to a Java object (deserialization), you can use @JsonProperty to customize the mapping between the Java class attributes (fields) and the JSON properties.
5.  do you know what is jackson?
    Jackson is a popular open-source Java library used for handling JSON data (JavaScript Object Notation). It provides functionality to serialize Java objects to JSON (serialization) and to deserialize JSON data back into Java objects (deserialization). Jackson is widely used in Java-based web applications, RESTful APIs, and other projects where data needs to be exchanged in JSON format.
6.  What is spring-boot-stater?
    a. what dependecies in the below starter? do you know any starters?
7. do you know  @RequestMapping(value = "/users", method =
   RequestMethod.POST) ? could you list CRUD by this style?
   @RequestMapping(value = "/users", method = RequestMethod.POST) is an annotation that means map the incomming HTTP to a specific methods in a controller class. This annotation means the path is /users and the method that this controller class will handle is POST method. CRUD: create: @PostMapping read: @GetMapping(path) update: @PutMapping(path) delete: @DeleteMapping(path)
8.  What is ResponseEntity? why do we need it?
    ResponseEntity is a powerful class that allows you to create well-structured, customizable, and standardized HTTP responses in Spring-based web applications. It enhances the control and consistency of your API responses, making it an essential tool for building robust and user-friendly web services.
9.  What is ResultSet in jdbc? and describe the flow how to get data using JDBC
    The ResultSet interface provides methods to retrieve and manipulate the data from the result set, such as getting column values, moving the cursor to the next row, checking if there are more rows available, and closing the result set when it's no longer needed.

Here's an overview of the typical flow to get data using JDBC:

Load JDBC Driver and Establish Connection:
First, you need to load the JDBC driver for the specific database you are using. This is done using the Class.forName() method. Then, establish a connection to the database using the DriverManager.getConnection() method, providing the database URL, username, and password.

Create and Execute the SQL Query:
After obtaining a connection to the database, you need to create a Statement object from the connection using connection.createStatement(). Then, you can use this Statement object to execute your SQL query using the executeQuery() method, which returns a ResultSet.

Iterate through the ResultSet:
Once you have the ResultSet, you can start navigating through the result set using methods like next() to move to the next row and isLast() to check if you are at the last row. You can then use various getXXX() methods (e.g., getInt(), getString(), etc.) to retrieve the values of the columns for the current row.

Process the Data:
As you navigate through the ResultSet, you can process the data retrieved from the database. You might use this data to populate Java objects, display information to users, or perform further calculations and business logic.

Close Resources:
After you have finished working with the ResultSet, you should close it using the close() method to release any associated resources. Additionally, remember to close the Statement and Connection objects using their close() methods as well.
10. What is the ORM framework?
    Sure! An ORM framework (Object-Relational Mapping) is a tool that helps Java developers work with databases using object-oriented concepts. It allows you to treat database tables as regular Java classes and interact with them like objects. This simplifies database operations, reduces boilerplate code, and makes the code more readable and maintainable. Popular ORM frameworks in Java include Hibernate and EclipseLink. They handle the mapping between objects and database tables, letting you focus on your application's logic without worrying about low-level database details.
11. Learn how to use ObjectMapper by this example.
    <dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.13.3</version>
    <scope>compile</scope>
    </dependency>
    1
    2
    3
    4
    5
    6
    <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    1
    2
    3
    4
    new ResponseEntity<>(postResponse, HttpStatus.OK);
    new ResponseEntity<>(postResponse,
    HttpStatus.CREATED);
    ResponseEntity.ok(postService.getPostById(id));
    1
    2
    3
    No. 1 / 2
    a. https://github.com/TAIsRich/chuwa-eij-tutorial/blob/main/02-java-cor
    e/src/main/java/com/chuwa/exercise/oa/api/FoodOutletJackson.java
12. What is the serialization and desrialization?
    a. https://hazelcast.com/glossary/serialization/
    Serialization is the process of converting data or objects into a format suitable for storage or transmission, like converting objects into JSON or XML.

Deserialization is the reverse process of converting the stored or transmitted data back into its original form, like converting JSON or XML data back into objects
13. use stream api to get the average of the array [20, 3, 78, 9, 6, 53, 73, 99, 24, 32].
    List<Integer> list = List.of(20, 3, 78, 9, 6, 53, 73, 99, 24, 32);
    list.stream().mapToInt(n->n.intValue()).average().orElse(0.0);