2.  What is Spring and Springboot? What is the benfits of using Srpingboot?
    Spring is a popular Java framework for building applications, and Spring Boot is a part of it that streamlines 
    development and configuration. The key benefits of using Spring Boot are faster development, easy setup, built-in 
    server, ready-to-use features, and great support for microservices. It simplifies the process of creating modern 
    and scalable applications, saving developers time and effort.

3.  What is IOC and What is DI?
Inversion of Control (IOC):
IOC is a design principle that refers to the inversion of the traditional flow of control in a program.
In traditional programming, the application itself is responsible for creating and managing the objects it needs.
In contrast, with IOC, the control of object creation and management is delegated to a container or framework, like Spring.
The container manages the lifecycle of objects and injects dependencies into the objects that need them.
Dependency Injection (DI):

DI is a specific implementation of IOC, where one object supplies the dependencies of another object.
Instead of a class creating its dependencies internally, the dependencies are "injected" into the class from the outside.
DI promotes loose coupling between components, making the application more maintainable and testable.
In Spring, DI is achieved using techniques like constructor injection, setter injection, or method injection.
    
4.  What is  @CompnonentScan?
@ComponentScan is a Spring annotation used for automatic discovery of Spring-managed components (beans) in the application.
It scans specified packages and registers the classes with Spring stereotypes (@Component, @Service, etc.) as beans in 
the application context.

5.  How to define which package spring need to scan in xml and annotaiton?
    @Configuration
    @ComponentScan("com.example.myapp")
    public class AppConfig {
    // Other bean definitions go here
    }
6.  What is  @SpringbootApplication?
@Configuration: Indicates that the class is a source of bean definitions. It allows you to define Spring beans using the @Bean annotation within the class.
@EnableAutoConfiguration: Enables Spring Boot's auto-configuration mechanism. It automatically configures the Spring application based on the dependencies present in the classpath and the configuration provided.
@ComponentScan: Scans the specified base package and its sub-packages for Spring components, such as @Component, @Service, @Repository, etc., and registers them as Spring beans.
7. How many ways wo can define a bean?
XML Configuration: Beans can be defined in an XML configuration file using the <bean> element. The XML configuration is the traditional and classic way of defining beans in Spring.
Java Configuration (Annotation-based): Beans can be defined using Java configuration classes annotated with @Configuration. Within these classes, beans are defined using @Bean annotations on methods that return the bean instances.
Java Configuration (Component Scanning): By using annotations such as @Component, @Service, @Repository, etc., along with @ComponentScan on the configuration class, Spring can automatically discover and register beans by scanning specified packages.
8.  What is default bean name for  @Component and  @Bean?
@Component
public class MyBean{}  --> myBean

@Bean
public ABC efg(){
    return new ABC();
} --> efg
9.  What is the difference between  @component and  @service,@repository?
    @Component: Generic annotation for any Spring-managed bean.
    @Service: Indicates a Spring service bean, used for business logic and services.
    @Repository: Indicates a Spring repository bean, used for database interactions (e.g., DAO classes).
    All three are used to define Spring beans, but they carry different semantics to better organize and understand the purpose of the classes in the application.

10. How many annotaitons we can use to inject the bean?
@Autowired: Used for automatic injection of beans by type. It can be applied to fields, constructors, or setter methods.

@Qualifier: Used along with @Autowired to specify the bean name when multiple beans of the same type are present.

@Resource: Similar to @Autowired, it can also inject beans by name or type, but it's a part of the Java EE specification and provides more options for customization.

11. Tell me the three types to do dependency injection(How can we inject the beans
    in Spring)? Which way is better and why?
    The better way depends on the specific scenario and coding style, but Constructor Injection is generally considered 
a better practice. It ensures that all required dependencies are provided at the time of object creation, making the class 
more predictable and easier to test. It also promotes immutability, as the injected dependencies can be made final. 
Setter Injection is more flexible but can lead to objects being in an incomplete state if not all setters are called. 
Field Injection is the least preferred, as it hinders testability and makes the class tightly coupled with the Spring framework.
12. If we have multiple beans for one type, how to set one is primary? and how to let
    the spring to pick one bean to inject if no primay.
@Primary, specify the bean name
13. What is the difference between BeanFactory and ApplicationContext in Spring?
BeanFactory is basic with lazy initialization, while ApplicationContext adds more features and eagerly initializes 
singleton beans for immediate use. Most developers prefer using ApplicationContext for its convenience and added benefits.
14. What is the Scope of a Bean?  and list the examples for each scope.
    Singleton: The default scope. Only one instance of the bean is created, and it is shared across all requests for that bean within the container.
    Example: @Component, @Service, or @Repository without specifying a custom scope.

Prototype: A new instance of the bean is created each time it is requested from the container.
Example: @Scope("prototype") on a @Component class.

Request: A new instance of the bean is created for each HTTP request. Applicable only in a web-aware Spring application.
Example: @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS) on a @Controller.

Session: A new instance of the bean is created for each HTTP session. Applicable only in a web-aware Spring application.
Example: @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS) on a @Controller or @Component.

Global Session: Similar to the session scope, but applicable for a global HTTP session when using portlet contexts. It is used in a Portlet-based Spring application.
Example: @Scope(value = "globalSession", proxyMode = ScopedProxyMode.TARGET_CLASS) on a @Controller or @Component.

Application: Only one instance of the bean is created, and it is shared within the entire application context.
Example: @Scope(value = "application", proxyMode = ScopedProxyMode.TARGET_CLASS) on a @Controller or @Component.
15. Configure a bean using xml. If bean has parameters/dependencies, how can we
    configure the bean? (you can google the tutorial how to configure beans in xml,
    and feel free to ask me any quesitons if you don't understand. it is a little bit old,
    I am not sure if I need to exaplain it in class)
2.  What is MVC pattern?
Model: The Model represents the data and business logic of the application. It encapsulates the application's data and 
defines how it can be manipulated and accessed. The Model is responsible for processing and maintaining the data, as well 
as implementing the application's business rules and logic.

View: The View is responsible for presenting the data to the user and displaying the user interface. It represents 
the visual representation of the data provided by the Model. The View is passive and does not handle data processing; 
instead, it focuses on rendering the information in a user-friendly way.

Controller: The Controller acts as an intermediary between the Model and the View. It receives user input from the View 
and processes it, then interacts with the Model to retrieve or modify data accordingly. The Controller is responsible for 
updating the View with the latest data from the Model and handling user interactions.
3.  What is Front-Controller?
The Front Controller is a design pattern used in web applications to provide a centralized entry point for handling incoming 
requests and managing the flow of the application. It acts as a central controller that intercepts and routes all client 
requests to appropriate handlers for processing. The Front Controller pattern helps in achieving a single point of control, 
enhancing code organization, and promoting code reusability.
In the context of web development, the Front Controller pattern is commonly used in web frameworks to handle HTTP requests 
and manage the overall request-response cycle. When a user sends a request to a web application, the Front Controller intercepts 
that request and then delegates it to the appropriate handler (also known as a dispatcher) based on the requested URL or other criteria.
4.  What is DispatcherServlet? please decribe how it works.
    Front Controller: When a client (e.g., a web browser or mobile app) sends an HTTP request to a Spring-based web application, the request is first intercepted by the DispatcherServlet. The DispatcherServlet acts as the front controller, which means it serves as the single entry point for all incoming requests.

Handler Mapping: Once the DispatcherServlet receives the request, it consults the configured HandlerMapping(s) to determine which controller (handler) should handle the request. The HandlerMapping(s) map incoming requests to specific handler methods in the application.

Controller Execution: Once the appropriate handler method is determined, the DispatcherServlet invokes the corresponding controller (handler) to process the request. The controller performs the required business logic and prepares the data to be displayed or processed.

View Resolver: After the controller has processed the request, it returns a logical view name. The DispatcherServlet then consults the configured ViewResolver(s) to find the actual view (e.g., JSP, Thymeleaf template, or JSON data) that corresponds to the logical view name.

View Rendering: Once the view is resolved, the DispatcherServlet renders the view by passing the model data to the view template. The view template combines the model data with the view's structure to generate the final output.

Response: Finally, the DispatcherServlet sends the generated response back to the client, completing the request-response cycle.
5.  What is JSP and What is ModelAndView？(please google to have a basic
    knowlege)\
    SP is a technology for creating dynamic web pages by embedding Java code within HTML, while ModelAndView is a class used in the Spring Framework to handle the flow of data between controllers and views, making it easy to pass data from the server to the view templates for rendering.
6.  Could you please google any other servlets(理解多少是多少，不要花太多时间，
    知道servlet的名字就行。)
7. How many web server do you know? (Tomcat, Jetty, Jboss)
just tomcat