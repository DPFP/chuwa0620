# hw47

### 2.what is selenium?
Selenium is an open-source framework for automating web browsers. It provides a way to control a web browser, allowing developers and testers to script actions that a user might take in their browser, like clicking buttons or typing into fields. Selenium can be used with various browsers like Chrome, Firefox, Safari, and Internet Explorer.

### 3.what is cucumber?
Cucumber is a tool used for Behavior-Driven Development (BDD), a software development methodology that encourages collaboration between developers, QA, and non-technical stakeholders in a software project.

### 4.what is JMeter?
Apache JMeter is an open-source software application designed for load testing and performance measurement of web applications, web services, databases, and more. It's part of the Apache Software Foundation's Jakarta Project and is widely used for analyzing and measuring the performance of various services.

### 5.What is the lifecircle of Junit?
@BeforeClass: This annotation marks a method that will be run once before any of the test methods in the class. It is often used for one-time setup that applies to all test methods, such as opening a database connection.

@Before: This annotation marks a method that will be run before each test method. It's a place to set up common test fixture data that each test might change or use.

Test Method (@Test): This is where the actual test is conducted. You can have multiple test methods in a test class, and each one is marked with the @Test annotation.

@After: This annotation marks a method that will be run after each test method. It's used for teardown actions that must occur after each test, such as closing resources or rolling back a database transaction.

@AfterClass: This annotation marks a method that will be run once after all the test methods in the class have been run. It's often used for one-time teardown, such as closing a database connection.

```java
import org.junit.*;

public class ExampleTest {

    @BeforeClass
    public static void setUpClass() {
        System.out.println("Once before all tests");
    }

    @Before
    public void setUp() {
        System.out.println("Before each test");
    }

    @Test
    public void test1() {
        System.out.println("Test 1");
    }

    @Test
    public void test2() {
        System.out.println("Test 2");
    }

    @After
    public void tearDown() {
        System.out.println("After each test");
    }

    @AfterClass
    public static void tearDownClass() {
        System.out.println("Once after all tests");
    }
}
```

### 6.Is @BeforeAll method should be Class level(static)?
Yes, in JUnit 5, the method annotated with @BeforeAll must be static, and it is executed once before all the test methods in the test class. The reason for this is that @BeforeAll is used for setting up a common state or configuration for all the test methods in the class, and it is called before an instance of the test class is created.

### 7.What is Mockito? and what is its limitations?  what kind of tools can give help?
Mockito is a popular open-source mocking framework for unit testing in Java. It allows developers to create and configure mock objects, which can be used to replace real objects in tests. By using mock objects, you can isolate the code under test from its dependencies, making the tests more focused and easier to maintain.
However, it has disadvantage that it can not mock final static methods.

### 8.What is @Mock and what is @InjectMocks?
The @Mock annotation is used to create a mock object. It replaces the constructor call typically used with mock(Class). The annotated field's type is used to create the mock.
```java
import static org.mockito.Mockito.*;
import org.mockito.Mock;
import org.junit.jupiter.api.Test;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(MockitoExtension.class)
public class MyTest {

    @Mock
    MyService myService;  // A mock of MyService is automatically created

    @Test
    public void testMethod() {
        when(myService.performAction()).thenReturn("Mock Response");
        // rest of the test
    }
}
```

The @InjectMocks annotation is used to automatically inject mock objects into the object under test. Mockito will try to inject mocks either by constructor injection, setter injection, or property injection (in that order), depending on what's available.
```java
import org.mockito.InjectMocks;

public class MyTest {

    @Mock
    MyService myService;  // A mock of MyService is created

    @InjectMocks
    MyClass myClass; // The mock MyService is injected into MyClass

    // rest of the test
}
```

### 9.What is the stubbing (define behaviors)?
Stubbing is a technique used in testing to control the behavior of dependencies or modules that a particular unit of code relies on. By defining the behavior of these dependencies for the scope of the test, you can isolate the code you are testing and ensure that it behaves as expected regardless of the actual implementation of its dependencies.
```java
import static org.mockito.Mockito.*;

public class UserServiceTest {

    @Test
    public void testGetUser() {
        // Create a mock UserRepository
        UserRepository userRepository = mock(UserRepository.class);

        // Stubbing: define the behavior for the mock
        when(userRepository.findById(1)).thenReturn(new User(1, "Alice"));

        // Create the service with the stubbed repository
        UserService userService = new UserService(userRepository);

        // Test the service method
        User user = userService.getUserById(1);

        // Assert the result
        assertEquals("Alice", user.getName());
    }
}
```

### 10.what is Mockito ArgumentMatchers
In Mockito, Argument Matchers are powerful expressions that you can use when stubbing or verifying method calls. They allow you to generalize the matching criteria for method arguments. Instead of specifying an exact value that a method parameter should have, you can use Argument Matchers to define more flexible rules for matching parameters.

### 11.what is Hamcrest Matchers
Hamcrest is a framework for writing matcher objects allowing 'match' rules to be defined declaratively. It's used in conjunction with testing frameworks like JUnit to improve the readability and maintainability of tests. Hamcrest matchers enable you to write flexible and expressive assertions in your tests, with a syntax that reads more like natural language.

### 12.do you know @spy? what is difference between @spy and @Mock?
both @Spy and @Mock are annotations used in Mockito for creating spy and mock objects, respectively. 
Use @Mock when you need a completely controlled object where you specify all its behavior.
Use @Spy when you want to base the behavior on a real object but need to intercept some method calls or change the behavior of certain methods.

### 13.What is assertion?
An assertion is a statement in code that verifies if a specific condition is true or false. It's a way to test if the assumptions about the state of a program are correct at a particular point in time. Assertions are commonly used in testing to ensure that the code behaves as expected.
```java
import static org.junit.Assert.assertEquals;

public class CalculatorTest {
    @Test
    public void testAddition() {
        Calculator calculator = new Calculator();
        int result = calculator.add(5, 3);
        assertEquals("The addition of 5 and 3 should equal 8", 8, result);
    }
}
```

### 14.If you have developed a new feature, how many types of tests for this feature? and what kind of tests are written by you? what is the purpose of each type of tests?
The first one is Unit Test, second one is Integration Test, the third one is Regression Tests.
Unit test is to test the single unit and it is writen by me.
Integration Test is to test the unit with the current system.
Regression Tests is to make sure the new feature will out negatively impact the existing functionality.