# 2. what is selenium
Selenium is an open-source software framework commonly used for automating web browsers. It provides a suite of tools and libraries that allow developers and testers to interact with web applications and perform automated testing, web scraping, and browser automation tasks.

# 3. what is cucumber?
Cucumber is a popular open-source tool used for behavior-driven development and acceptance testing. It allows developers, testers, and non-technical stakeholders to collaborate and define the behavior of a software system using a plain-text format called Gherkin.

# 4. what is JMeter?
JMeter is primarily used for load testing, stress testing, and performance testing of web applications, APIs, and various other services.

# 5.  What is the lifecircle of Junit?
@BeforeAll -> @BeforeEach -> @Test -> @AfterEach -> @AfterAll

# 6.  Is @BeforeAll method should be Class level(static)?
The @BeforeAll method should be at the class level and must be static. Similarly, there is a corresponding annotation called @AfterAll that should also be at the class level and static.

# 7. What is Mockito? and what is its limitations?  what kind of tools can give help?
Mockito is a popular open-source Java library used for mocking objects in unit testing. It allows developers to create mock objects, which are objects that simulate the behavior of real objects but do not perform any actual operations.

Mockito cannot mock final classes and methods. This could be fixed by using PowerMock. PowerMock is an extension of Mockito that can mock final classes and static methods, overcoming one of Mockito's limitations.

# 8.  What is @Mock and what is @InjectMocks?
The @Mock annotation is used to create a mock object for a class or interface. When you annotate a field or a parameter with @Mock, Mockito will create a mock instance of the corresponding class or interface. This allows you to specify the behavior of the methods on the mock object during the test.


The @InjectMocks annotation is used to inject the mock objects created with @Mock into the class under test. When you annotate a field with @InjectMocks, Mockito will try to inject the mock objects into this field when the test class is created.

# 9.  What is the stubbing (define behaviors)?
Stubbing refers to the process of defining the behavior of mock objects or test doubles. When you create a mock object, it starts with default behavior that does nothing or returns default values. However, programmer often need to specify how the mock should behave to simulate different scenarios.

# 10. what is Mockito ArgumentMatchers
Mockito ArgumentMatchers are utility methods provided by the Mockito library to specify flexible matching criteria for method arguments when stubbing or verifying interactions with mock objects. Some common Mockito ArgumentMatchers include:'any()','eq()','isNull()','anyVararg()'.

# 11. what is Hamcrest Matchers
Hamcrest Matchers is a framework that provides a set of matchers for writing expressive and readable assertions in testing frameworks like JUnit, TestNG, and Mockito. Hamcrest aims to improve the readability of test code by allowing programmers to create custom assertions using a fluent and declarative syntax.

# 12. do you know @spy? what is difference between @spy and @Mock?
@Mock is used to create a mock object of a class or interface. When you annotate a field or a parameter with @Mock, Mockito will create a complete mock object that replaces the real implementation of the class or interface.

@Spy is used to create a partial mock object. It allows you to keep the real implementation of the class while selectively mocking certain methods of that class.

# 13. What is assertion
An assertion is a statement or a piece of code that checks whether a specific condition is true or false. Assertions are used to verify that the actual behavior of the code under test matches the expected behavior.

# 14. If you have developed a new feature, how many types of tests for this feature? and what kind of tests are written by you? what is the purpose of each type of tests?
1. Unit tests: focus on testing individual units or components of the feature in isolation
2. Integration tests: verify that different components or units of the feature work together correctly when integrated
3. Regression tests: ensure that the new feature has not introduced any unintended side effects or broken existing functionality.
4. Performance/Load tests: help identify performance bottlenecks and ensure that the feature can handle the expected user load
5. A/B Test: gather valuable feedback from users before the official launch

The programmer may involve in unit tests and integration tests.