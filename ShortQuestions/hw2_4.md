# HW2_4

## Q1: Explain volatile variables in java. (we also use it in Singleton)
the `volatile` keyword is used with variables that are accessed by multiple threads. <br>
It ensures that the value of the volatile variable is always read from and written to the main memory, and not cached locally by threads.
main features of `volatile`: <br>
1. **Visibility**: Changes made to a volatile variable in one thread are immediately visible to other threads.
2. **Atomicity**: volatile guarantees atomicity of simple read and write operations (i.e., single operations of reading or writing a variable).
3. However, volatile does not guarantee atomicity for compound operations (i.e., operations that involve reading a variable, changing it, and writing the new value back), such as counter++.


## Q2: how to create a new thread(Please also consider Thread Pool case)?
1. Extends Thread class
2. Implements Runnable interface
3. Implements Callable interface
4. Creating a thread pool using the `ExecutorService`

## Q3. Difference between Runnable and Callable
1. **Return Value** <br>
  `Runnable.run()` does not return a result. It's return type is void. <br>
  `Callable.call()` returns a result. The Callable interface is a generic interface, meaning you specify the return type when you implement it, as in `Callable<Integer>` or `Callable<String>`.
2. **Exception Handling** <br>
  `Runnable.run()` cannot throw any checked exceptionsâ€”only unchecked exceptions. <br>
  `Callable.call()` can throw checked as well as unchecked exceptions.

## Q4. What is the diff between t.start() and t.run()?
`t.start()`: used to start a new thread of execution. When you call t.start(), the Java Virtual Machine calls the run() method of the Thread object in a new thread of execution. <br>
`t.run()`: regular method call, won't utilize multithreading.

## Q5. Which way of creating threads is better: Thread class or Runnable interface?
`Runnable` interface is generally considered better. <br>
1. **Java doesn't support multiple inheritance**: If you inherit one class, you cannot another class.
2. **Can use runnable**: can use lambda expressions to write a Runnable more concisely.

## Q6. What is the thread status?
1. **New**:  A thread that has not yet started is in this state.
2. **RUNNABLE**: A thread executing in the Java virtual machine is in this state.
3. **BLOCKED**: A thread that is blocked waiting for a monitor lock is in this state.
4. **WAITING**: A thread that is waiting indefinitely for another thread to perform a particular action is in this state.
5. **TIMED_WAITING**: A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.
6. **TERMINATED**: A thread that has exited is in this state.

## Q7. Difference between the wait() and sleep() methods?
1. **Class where they are defined**: `wait()` method is defined in the Object class, and `sleep()` is a static method defined in the Thread class.
2. **Synchronization context**: Once `wait()` is called, the thread releases the lock on the object and goes into a waiting state.
It will remain in the waiting state until another thread calls `notify()` or `notifyAll()` on that object. <br>
`sleep()` doesn't interact with the object monitor and doesn't release any locks that the thread holds. Other threads cannot execute the same synchronized block of code until the sleeping thread wakes up and releases the lock.
3. **Wakeup Condition**: A thread that has called `wait()` will wake up when either `notify()` or `notifyAll()` is called on the same object (from another thread).
   A thread that is in `sleep()` will wake up after the specified sleep time has passed, or when it's interrupted by another thread.
   
## Q8. What is deadlock?
Deadlock refers to a specific condition where two or more threads are unable to proceed because each is waiting for the other to release a resource. 

## Q9. How do threads communicate with each other?
1. **Shared Objects and Variables**: One thread can change the state of a shared object, and other threads can read this state to get the data.
   Synchronization must be used in this case to ensure data consistency and to avoid problems such as race conditions.
2. **`wait()`, `notify()`, and `notifyAll()` methods**: A thread calls `wait()` to wait for a signal from another thread, which signals by calling `notify()` or `notifyAll()`.
   This mechanism is typically used for managing situations where threads need to wait for some condition to be true, such as a queue being non-empty.

## Q10. what is join() method?
This method allows one thread to wait until another thread completes its execution.

## Q11. what is yield() method?
This is a static method that causes the currently executing thread to pause and allow other threads to execute. <br>
t's generally used in situations where a thread is doing an intensive computation and wants to give other threads of the same priority a chance to run.

## Q12. Explain the thread pool.
A thread pool in Java holds a number of worker threads, and these threads can be both idle or running tasks depending on the state of the program:

When a thread pool is created, it either initializes with a set number of threads or starts out empty and creates new threads on-demand. These threads wait idle until a task is submitted to the executor service managing the pool.

When a task (in the form of a Runnable or Callable object) is submitted to the executor service, it is put into a task queue. Threads in the pool then take tasks from this queue and run them. 
If all threads are currently busy running tasks, and the maximum number of threads in the pool has not been reached, the executor service may create a new thread to run the task.

Once a thread has completed a task, it returns to the pool and becomes idle, waiting for the next task. If the pool is larger than the core size and a thread has been idle for a certain amount of time, the thread may be terminated and removed from the pool to save resources.

## Q13. What is Executor Framework in Java, its different types, and how to create these executors?
The Executor framework is a framework that helps to create and manage threads. 
It consists of `Executor`, `ExecutorService`, `ScheduledExecutorService` interfaces
It allows you to control the number of threads that are being created, run, and destroyed. <br>
Once you've got your ExecutorService instance, you can submit tasks (`Runnable` or `Callable` objects) to it for execution:
```
executor.submit(() -> {

});
```

## Q14. Difference between shutdown() and shutdownNow() methods of executor.
1. `shutdown()`:  initiates an orderly shutdown of the executor service. It allows previously submitted tasks to complete execution while preventing new tasks from being accepted.
2. `shutdownNow()`: This method attempts to stop the executor immediately by interrupting the executing tasks and discarding pending tasks.

## Q15. What is Atomic classes? when do we use it?
Atomic classes in Java, such as `AtomicInteger`, `AtomicLong`, and `AtomicBoolean`, provide atomic operations on single variables without the need for explicit synchronization. <br>
These classes ensure that operations on the variables are atomic, meaning they are indivisible and cannot be interrupted by other threads. <br>
They guarantee that no other thread can observe an intermediate state of the variable during the operation. <br>
They allow atomicity, thread safety, concurrency control and better performance than using locks or synchronized blocks.

## Q16. What is the cocurrent collections?
Concurrent collections in Java are a set of thread-safe data structures designed to be used in concurrent programming scenarios where multiple threads access and modify shared data concurrently. <br>
1. `ConcurrentHashMap`: a thread-safe implementation of the `Map` interface.
2. `ConcurrentSkipListSet`: a thread-safe implementation of the `SortedSet` interface.
3. `ConcurrentLinkedQueue`: a thread-safe implementations of the `Queue` interface.

Advantages: Thread safety + minimize contention and synchronization overhead. -> improve performance + atomic operations.

## Q17. what kind of locks do you know?

## Q18. What is the difference between class lock and object lock?
1. Class lock: to synchronize static methods or static code block such that only one thread can access the static variables at a time (at class level)
2. Object lock: to synchronize non-static methods or non-static code blocks such that only one thread can access the instance variables at a time.

## Q19. What is `Future` and `completableFuture`?
`Future` and `CompletableFuture` are used for asynchronous programming. <br>
1. `Future`: represents the pending result of an asynchronous computation. It provides methods to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation.
The result can only be retrieved when the computation has been completed; the `get` method will block if the computation has not yet been completed.
2. `CompletableFuture`: extension to `Future`. It provides a large number of methods for creating, chaining, and combining multiple futures.
You can add `thenApply`, `thenAccept`, `thenCompose`, and `thenCombine` methods to the CompletableFuture to specify what should happen when the future completes.


## Q20. What is ThreadLocal?
Thread-local variables are variables that each thread has its own independently initialized copy of. (One thread -> one copy)
The most typical use of ThreadLocal is to store the per-thread state that is used across different methods.

