#### 1. List all of the annotations you learned from class and homework to annotaitons.md

#### 2. Type the Comment feature for the class project.

#### 3. In postman, call of the APIs in PostController and CommentController.

#### 4. what is JPA? and what is Hibernate?

**JPA is the Java specification and not the implementation.** **Hibernate is an implementation of JPA and uses common standards of Java Persistence API**. It is the standard API that allows developers to perform database operations smoothly

#### 5. What is Hiraki? what is the benefits of connection pool?

What is the benefit of Hikari connection pool?

"HikariCP is solid high-performance JDBC connection pool. A connection pool is a cache of database connections maintained so that the connections can be reused when future requests to the database are required. Connection pools **may significantly reduce the overall resource usage**

#### 6. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.

1. `@ManyToOne`: This is used on the **child side** of the relationship and indicates that each instance of this entity is associated with one instance of another entity.

   For example, a Book entity that belongs to one Author:

   ```java
   javaCopy code@Entity
   public class Book {
       @ManyToOne
       private Author author;
       // ...
   }
   ```

2. `@OneToMany`: This is used on the **parent side** of the relationship, indicating that one instance of this entity is associated with multiple instances of another entity.

   For example, an Author entity that has many Books:

   ```java
   javaCopy code@Entity
   public class Author {
       @OneToMany(mappedBy = "author")
       private List<Book> books;
       // ...
   }
   ```

3. `@ManyToMany`: This is used when multiple instances of this entity are associated with multiple instances of another entity.

   For example, a Student entity that has many Courses, and a Course can also be taken by many Students:

   ```java
   javaCopy code@Entity
   public class Student {
       @ManyToMany
       private List<Course> courses;
       // ...
   }
   
   @Entity
   public class Course {
       @ManyToMany(mappedBy = "courses")
       private List<Student> students;
       // ...
   }
   ```

#### 7. What is the cascade = CascadeType.ALL, orphanRemoval = true? and whatare the other CascadeType and their features? In which situation we choose which one?

`CascadeType` and `orphanRemoval` are options that you can set on your JPA associations to define how operations are cascaded from parents to children entities.

1. `cascade = CascadeType.ALL`: This means that any operation (Persist, Remove, Refresh, Merge, Detach) made on the parent entity will be cascaded to the child entities. This is useful when you want to perform the same operation on the child entities without explicitly invoking it.
2. `orphanRemoval = true`: This means that if you remove the association of a child entity from its parent, that child entity will be automatically removed from the database as well.

The choice of cascade type depends on your application's needs:

- If you want all operations to cascade, use `CascadeType.ALL`.
- If you only want saves to cascade, but not deletions or merges, use `CascadeType.PERSIST`.
- If you want all operations to cascade except for deletion, use `CascadeType.PERSIST`, `CascadeType.MERGE`, `CascadeType.REFRESH`, and `CascadeType.DETACH`.
- If you want to automatically remove a child entity when it's no longer associated with its parent, set `orphanRemoval = true`.

#### 8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?

`FetchType.LAZY` and `FetchType.EAGER` are hints to the JPA provider about when to fetch the related entities.

1. `FetchType.LAZY` (default for `@OneToMany` and `@ManyToMany`): The related entities are fetched from the database only when you directly access them. This is called "lazy initialization". This can be more efficient as it doesn't load the related entities if they're not needed, which can be useful for associations with many entities.
2. `FetchType.EAGER` (default for `@OneToOne` and `@ManyToOne`): The related entities are fetched from the database at the same time when the parent entity is fetched. This can be more efficient when you know you'll always need the related entities every time you fetch the parent.

The choice between `LAZY` and `EAGER` largely depends on the specific requirements of your use case:

- If accessing the parent entity usually needs to access the related entities as well, `FetchType.EAGER` could be a good choice, as it avoids additional database hits.
- If the related entities are rarely used, or the number of related entities could be large, then `FetchType.LAZY` is a better choice as it reduces unnecessary database traffic and memory usage.

#### 9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?

JPA doesn't have a strict naming convention, but in the context of Spring Data JPA, there's a query method naming convention which allows the framework to automatically generate SQL queries based on method names in your repository interface.

Here are the rules:

- Start with `find`, `read`, `get`, `count`, or `delete`. This indicates the operation.
- Add `By` to separate the operation from property names.
- Then specify the property of the entity you want to use for the query. For nested properties, use underscore `_`.

No implementation is needed! Spring Data JPA will generate the implementation for you based on these method names.

Here are some examples:

1. `findById(Long id)`: It will generate a query that selects a user where the id matches the parameter provided.
2. `findByEmail(String email)`: Generates a query that selects a user where the email matches the provided email.
3. `countByLastName(String lastName)`: Generates a query that counts all users with the matching last name.
4. `deleteByEmail(String email)`: Generates a query that deletes all users with the matching email.
5. `findByAddress_City(String city)`: If the User entity has an Address entity and the Address entity has a city property, this will generate a query to find all users where the city of their address matches the provided city.

#### 10. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.

#### 11. (Optional) Check out a new branch(https://github.com/TAIsRich/springboot-red book/tree/hw02_01_jdbcTemplate) from branch 02_post_RUD, replace the dao layer using JdbcTemplate.

#### 12. (Optional) use JDBC to read the data from database.

#### 13. type the code, you need to checkout new branch from branch 02_post_RUD,name the new branch with https://github.com/TAIsRich/springboot-redbook/tree/hw05_01_slides_JPQL.

#### 14. What is JPQL?

 JPQL is similar to SQL in its syntax. The main difference between JPQL and SQL lies in that **the former deals with JPA entities, while the latter deals directly with relational data**.

#### 15. What is @NamedQuery and @NamedQueries?

`@NamedQuery`: This annotation is used to declare queries statically in the metadata. A `@NamedQuery` is defined at the entity level and can be used for read-only operations.

```Java
@Entity
@NamedQuery(
    name="findCustomerByName",
    query="SELECT c FROM Customer c WHERE c.name LIKE :custName"
)
public class Customer {
    // ...
}

```

`@NamedQueries`: This annotation is used when you need more than one named query in an entity. It groups `@NamedQuery` annotations.

Here is an example of `@NamedQueries`:

```Java
@Entity
@NamedQueries({
    @NamedQuery(
        name="findCustomerByName",
        query="SELECT c FROM Customer c WHERE c.name LIKE :custName"
    ),
    @NamedQuery(
        name="findCustomerByEmail",
        query="SELECT c FROM Customer c WHERE c.email LIKE :custEmail"
    )
})
public class Customer {
    // ...
}

```



#### 16. What is @Query? In which Interface we write the sql or JPQL?

`@Query` 是一个用于 Java 持久化 API (JPA) 的注解，它允许你在 Spring Data JPA 的 repository 接口中直接写 SQL 或者 JPQL (Java Persistence Query Language) 查询

```java
public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT u FROM User u WHERE u.email = ?1")
    User findByEmail(String email);
}

```



#### 17. What is HQL and Criteria Queries?

**HQL is to perform both select and non-select operations on the data, but Criteria is only for selecting the data, we cannot perform non-select operations using criteria**. HQL is suitable for executing Static Queries, where as Criteria is suitable for executing Dynamic Queries.

#### 18. What is EnityManager?

The EntityManager API is *used to create and remove persistent entity instances, to find entities by their primary key*, and to query over entities.

#### 19. What is SessionFactory and Session?

**The SessionFactory is a thread safe object and used by all the threads of an application.** **A Session is used to get a physical connection with a database**. The Session object is lightweight and designed to be instantiated each time an interaction is needed with the database.

#### 20. What is Transaction? how to manage your transaction?

A transaction simply represents a unit of work.

@transaction

#### 21. What is hibernate Caching?

Caching in Hibernate refers to **the technique of storing frequently accessed data in memory to improve the performance of an application that uses Hibernate as an Object-Relational Mapping (ORM) framework**

#### 22. What is the difference between first-level cache and second-level cache?

The primary difference is that the first level cache is maintained at the Session level while the second level cache is maintained at the SessionFactory level. 2) The data stored in the first level cache is accessible to the only Session that maintains it, while the second level cache is accessible to all.

#### 23. How do you understand @Transactional? (不要clone，要⾃⼰抄写并测试 transactional，https://github.com/TAIsRich/tutorial-transaction)

#### 24. Write a simple factory design pattern.

