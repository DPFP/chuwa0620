# HW15
## Name: Yuanzhen Lin


1. List all of the annotations you learned from class and homework to annotaitons.md\
In annotation.md file


2. Briefly reading: https://www.techgeeknext.com/spring-boot/spring-aop-intervie w-questions\
Finished reading


3. What is the Aspect Oriented Programming?

Aspect-Oriented Programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. 

It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a "pointcut" specification. This allows behaviors that are not central to the business logic (such as logging, data validation, security, etc.) to be added to a program without cluttering the code that is central to the functionality.


4. What are the advantages and disadvantages of Spring AOP?
- Advantages of Spring AOP
  - It is easy to configure.
  - Spring AOP is implemented in pure Java, so separate compilation unit or separate class loader are not required.
  - It utilizes Spring's IOC container for dependency injection.
  - Can create aspects using @AspectJ annotation based or using XML based.
  - It integrates cross-cutting concerns into the classes,.

- Disadvantages of Spring AOP
  - Debugging the AOP framework-based application code is a little challenge.
  - Only methods with a public visibility will be recommended, not those with a private, protected, or default visibility.
  - Aspects cannot be advised by other aspects. This is because once a class is marked as an aspect (using XML or annotation), Spring prevents it from being auto-proxied.

5. What is Aspect in Spring AOP?

An aspect is a cross-cutting module that combines advice and pointcuts. A standard class tagged with the @Aspect annotation can be used to implement an aspect.

Aspects are mostly used to enable cross-cutting concerns like logging, profiling, caching, and transaction management.


6. What is Pointcut in Spring AOP?

A pointcut is an expression that chooses one or more join points at which advice is given. Pointcuts can be defined using expressions or patterns. It supports a number of expressions that correspond to the join points.


7. What is the Join point in Spring AOP?

A join point is a place in the application where an AOP aspect is applied. It could also be a specific advice execution instance. A join point in AOP can be a method execution, exception handling, changing the value of an object variable, and so on.


8. What does it mean by Advice and its types in Spring AOP?

The advice is an action which we take before or after the method execution. In the Spring AOP framework, there are five types of advice: before, after, after-returning, after-throwing, and around advice. Advice is taken at a specific join point.


9. Reading:https://www.javainuse.com/spring/sprbatch_interview \
Done


10. When to use Spring Batch?

Consider an environment where users have to do a lot of batch processing. This will be quite different from a typical web application which has to work 24/7. But in classic environments it's not unusual to do the heavy lifting for example during the night when there are no regular users using your system. Batch processing includes typical tasks like reading and writing to files, transforming data, reading from or writing to databases, create reports, import and export data and things like that. Often these steps have to be chained together or you have to create more complex workflows where you have to define which job steps can be run in parallel or have to be run sequentially etc. That's where a framework like Spring Batch can be very handy. Spring Boot Batch provides reusable functions that are essential in processing large volumes of records, including logging/tracing, transaction management, job processing statistics, job restart, skip, and resource management. It also provides more advanced technical services and features that will enable extremely high-volume and high performance batch jobs though optimization and partitioning techniques.Simple as well as complex, high-volume batch jobs can leverage the framework in a highly scalable manner to process significant volumes of information.


11. How Spring Batch works?

step - A Step that delegates to a Job to do its work. This is a great tool for managing dependencies between jobs, and also to modularise complex step logic into something that is testable in isolation. The job is executed with parameters that can be extracted from the step execution, hence this step can also be usefully used as the worker in a parallel or partitioned execution.

ItemReader - Strategy interface for providing the data. Implementations are expected to be stateful and will be called multiple times for each batch, with each call to read() returning a different value and finally returning null when all input data is exhausted. Implementations need not be thread-safe and clients of a ItemReader need to be aware that this is the case. A richer interface (e.g. with a look ahead or peek) is not feasible because we need to support transactions in an asynchronous batch.

ItemProcessor - Interface for item transformation. Given an item as input, this interface provides an extension point which allows for the application of business logic in an item oriented processing scenario. It should be noted that while it's possible to return a different type than the one provided, it's not strictly necessary. Furthermore, returning null indicates that the item should not be continued to be processed.

ItemStreamWriter - Basic interface for generic output operations. Class implementing this interface will be responsible for serializing objects as necessary. Generally, it is responsibility of implementing class to decide which technology to use for mapping and how it should be configured. The write method is responsible for making sure that any internal buffers are flushed. If a transaction is active it will also usually be necessary to discard the output on a subsequent rollback. The resource to which the writer is sending data should normally be able to handle this itself.


12. How can we schedule a Spring Batch Job?

There are a few different ways to schedule a Spring Batch job, but the most common method is to use Spring's built-in @Scheduled annotation in conjunction with a JobLauncher.

Here is an example of what this might look like:
```aidl
@Component
public class ScheduledTasks {

    @Autowired
    JobLauncher jobLauncher;

    @Autowired
    Job job;

    @Scheduled(cron = "0 * * * * ?")
    public void runSpringBatchJob() throws JobParametersInvalidException, JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException {
        JobParameters params = new JobParametersBuilder()
                .addString("JobID", String.valueOf(System.currentTimeMillis()))
                .toJobParameters();
        jobLauncher.run(job, params);
    }
}
```

13. What is the cron expression?

A cron expression is a string that represents a schedule in the Unix cron syntax. This format is used by many Unix-like operating systems for job scheduling. The cron format is also used by various other software applications, such as the Quartz job scheduler in Java.

The syntax of a cron expression can be quite complex, but at a basic level, it is composed of five or six (depending on the system) fields separated by white space, each representing a unit of time. They represent (in order):

- Minutes: a number from 0 to 59
- Hours: a number from 0 to 23
- Day of the month: a number from 1 to 31
- Month: a number from 1 (January) to 12 (December)
- Day of the week: a number from 0 (Sunday) to 7 (also Sunday). Some systems use values 1(Monday) to 7(Sunday).
- Year: Optional field. If specified, a number from 1970 to 2099.

Special characters can also be used:

- The asterisk (*) represents any value ("always").
- The comma (,) is used to specify a list of values.
- The hyphen (-) is used to define a range of values.
- The slash (/) is used to specify increments of a value.


Here are a few examples of cron expressions:

- 0 * * * * - runs once every hour, at the start of the hour (the 0th minute).
- 30 2 * * * - runs once per day, at 2:30 AM.
- 15 14 1 * * - runs once per month, on the first day of the month, at 2:15 PM.
- 0 0 * * 1-5 - runs once per day, at midnight, but only on weekdays (Monday through Friday).

In the Spring Framework, you can also use cron expressions in the @Scheduled annotation to schedule tasks.


14. What is the spring task?

Spring Task is a part of the Spring Framework that provides support for task scheduling and asynchronous method execution. It's built around the concept of the Executor interface from the java.util.concurrent package, and it offers a variety of executor implementations that can be used in different scenarios.

Task scheduling is the process of planning the execution of different tasks at specific times or with specific intervals. Spring Task provides several ways to schedule tasks:

- Fixed-rate scheduling: Tasks are scheduled at fixed intervals regardless of the duration of the previous task execution.

- Fixed-delay scheduling: The next task is scheduled after the completion of the previous task.

- Cron expression-based scheduling: The cron string can be used to schedule tasks.

Asynchronous method execution is the ability to execute methods in the background, separate from the main execution flow of your application. In Spring Task, this can be accomplished using the @Async annotation.

Here's an example of how to use the @Scheduled annotation for task scheduling:
```aidl
@Component
public class ScheduledTasks {

    @Scheduled(fixedRate = 5000)
    public void doSomething() {
        // this code will be executed every 5 seconds
    }
}
```
And here's an example of how to use the @Async annotation for asynchronous method execution:
```aidl
@Service
public class AsyncService {

    @Async
    public void doSomething() {
        // this method will be executed in a separate thread
    }
}
```

To enable task scheduling and asynchronous method execution in Spring, you need to add the @EnableScheduling and @EnableAsync annotations to one of your @Configuration classes:
```aidl
@Configuration
@EnableScheduling
@EnableAsync
public class AppConfig {

}
```

These features can be very useful in a variety of situations, such as executing heavy computations, sending emails, or running background tasks.


15. When to use Spring task?

Spring Task can be used when you need to schedule tasks or execute methods asynchronously in a Spring application. This can be useful in a variety of scenarios, including:

- Scheduling repetitive tasks: When you have tasks that need to be run at regular intervals, you can use Spring's @Scheduled annotation to specify the schedule. This could include tasks such as cleaning up old data, sending regular reports, or performing health checks.

- Long-running tasks: When your application has tasks that take a long time to execute and don't need to complete before the user gets a response, you can use the @Async annotation to run these tasks in the background. This can improve the responsiveness of your application by preventing the user from waiting for these long tasks to complete.

- Non-blocking IO operations: If you're working with IO operations (like reading and writing to a database or making network requests), these can often be done asynchronously to improve the throughput of your application. By using the @Async annotation, you can free up threads to handle other requests while waiting for the IO operation to complete.

- Scheduled data processing: If you need to process large amounts of data on a regular schedule (for example, nightly), you can use Spring Task to schedule these operations. This can be combined with Spring Batch to manage and optimize the data processing.

- Parallel processing: If you have tasks that can be executed in parallel to improve performance, you can use Spring's TaskExecutor abstraction to manage the execution of these tasks.

Remember that asynchronous execution and task scheduling come with their own complexities, such as error handling, transaction management, and thread-safety issues. Therefore, they should be used judiciously and tested thoroughly.


16. What is Filter and any filter example?

In the context of Spring and web applications, a filter is an object that performs filtering tasks on either the request to a resource, or on the response from a resource, or both. It's a part of the Java Servlet specification and can be used in any Java web application.

Filters are often used for a wide variety of tasks, such as:

- Authentication and Authorization: Ensuring that a user is authenticated and authorized to perform certain actions.
- Logging and auditing: Recording information about requests or responses, such as the time a request was made or the IP address of the client.
- Image conversion: Converting images into different formats.
- Data compression: Compressing responses to reduce bandwidth usage.
- Localization: Altering requests or responses to suit the specific locale (geographical and cultural location) of the user.
- XSS (Cross-Site Scripting) protection: Filtering out possible script injections.

Here's a basic example of a filter in a Spring application:


```aidl
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

public class CustomFilter implements Filter {
  
    @Override
    public void doFilter
      (ServletRequest request, 
      ServletResponse response, 
      FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest req = (HttpServletRequest) request;
        System.out.println(
          "Request URI is: " + req.getRequestURI());
        
        chain.doFilter(request, response);
    }
    
    // init and destroy methods can be used 
    // to manage resources (like database connections) 
    // if necessary
    
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void destroy() {
    }
}
```

This filter logs the URI of every incoming request. The doFilter method is where the logic of the filter is implemented. The chain.doFilter(request, response) call is very important as it allows the request to continue to its destination. If this method isn't called, processing of the request will stop at the filter.

To add the filter to your Spring application, you can use a FilterRegistrationBean:

```aidl
@Configuration
public class AppConfig {
  
    @Bean
    public FilterRegistrationBean<CustomFilter> loggingFilter(){
        FilterRegistrationBean<CustomFilter> registrationBean 
          = new FilterRegistrationBean<>();
          
        registrationBean.setFilter(new CustomFilter());
        registrationBean.addUrlPatterns("/*");
        
        return registrationBean;    
    }
}
```

This code will register the filter so that it applies to every request in the application. The addUrlPatterns("/*") call determines the URL patterns that the filter will be applied to.


17. What is the Interceptor? What we can do with interceptor?

In the context of Spring MVC, an interceptor is a component that can be used to intercept incoming HTTP requests and outgoing HTTP responses. They are often used to perform operations on these requests and responses before they reach their destination (the Controller) or leave the application, respectively.

Interceptors in Spring are defined by the HandlerInterceptor interface, which has three methods:

- preHandle(HttpServletRequest request, HttpServletResponse response, Object handler): This method is called before the actual handler is executed. It can be used for tasks such as logging, authentication, or modifying the request. It can also short-circuit the request and return a response immediately by returning false.

- postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView): This method is called after the handler is executed and the view is about to be rendered. It can be used for tasks like adding additional attributes to the model.

- afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex): This method is called after the entire request is completed. It can be used for cleanup work.

Here's an example of an interceptor:
```aidl
public class CustomInterceptor implements HandlerInterceptor {
  
    @Override
    public boolean preHandle
      (HttpServletRequest request, HttpServletResponse response, Object handler) {
        
        System.out.println("Before handler execution");
        return true;
    }

    @Override
    public void postHandle
      (HttpServletRequest request, HttpServletResponse response, Object handler, 
      ModelAndView modelAndView) throws Exception {
        
        System.out.println("Post Handle method is Calling");
    }
  
    @Override
    public void afterCompletion
      (HttpServletRequest request, HttpServletResponse response, Object handler, Exception exception) 
      throws Exception {
        
        System.out.println("Request and Response is completed");
    }
}
```

To register the interceptor, you can extend WebMvcConfigurer and override the addInterceptors method:
```aidl
@Configuration
public class AppConfig implements WebMvcConfigurer {
  
    @Autowired
    CustomInterceptor customInterceptor;
  
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(customInterceptor);
    }
}
```

Interceptors are often used for tasks like logging, adding common model attributes, handling multi-tenancy, applying themes, and handling authentication and authorization.


18. In Interceptor, What is preHandle? What is postHandle?

- preHandle(HttpServletRequest request, HttpServletResponse response, Object handler): This method is called before the actual handler is executed. It can be used for tasks such as logging, authentication, or modifying the request. It can also short-circuit the request and return a response immediately by returning false.

- postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView): This method is called after the handler is executed and the view is about to be rendered. It can be used for tasks like adding additional attributes to the model.


19. What is Swagger?

Swagger is a set of open-source tools built around the OpenAPI Specification that can help developers design, build, document, and consume RESTful web services. It includes tools to automatically generate documentation from your API code, as well as to generate client libraries.

Swagger is used for the same purpose - to document, design, and consume RESTful web services - and it is primarily integrated using libraries such as Springfox.

The primary components of Swagger are:

- Swagger Editor: An online editor which is a powerful tool that can be used to design APIs with the OpenAPI Specification. In the Swagger Editor, you can write OpenAPI specifications in YAML or JSON format.

- Swagger UI: A tool that dynamically generates beautiful documentation and a sandbox to explore and test your RESTful API services by parsing the OpenAPI Specification definitions. This interactive exploration of your API allows consumers to understand the capabilities of the service without accessing source code.

- Swagger Codegen: A template-driven engine which allows you to generate client SDKs, server stubs, and API documentation from an OpenAPI Specification.

Springfox is a set of Java libraries that can be used to automatically generate a Swagger documentation for Spring-based REST APIs. It does so by inspecting the endpoints and associated controllers and models in the Spring application, then generates detailed API documentation including what methods are available, the input parameters, output results, and possible error codes and messages.

To use Springfox in a Spring Boot application, you would typically add the following dependencies to your build file:

For Maven:
```aidl
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.9.2</version>
</dependency>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.9.2</version>
</dependency>
```



