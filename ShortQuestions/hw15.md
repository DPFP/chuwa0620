1. Done.
2. Document the Microservice Architecture and Components/Tools/Dependencies

    **Microservice Architecture:**
    - Divide the application into small, loosely coupled services.
    - Each service is responsible for a specific functionality.
    - Services communicate over the network, often using HTTP/REST APIs.
    
    **Components/Tools/Dependencies:**
    - Services: Individual microservices that handle specific tasks.
    - API Gateway: Handles external client requests and routes them to appropriate services.
    - Service Discovery: Helps services find and communicate with each other.
    - Load Balancer: Distributes incoming traffic across multiple instances of a service.
    - Database: Each service may have its own dedicated database.
    - Docker/Containers: Used for packaging and deploying services.
    - Kubernetes: Orchestrates and manages containers.
    - Monitoring Tools: Monitor health, performance, and logs of services.

3. Resilience Patterns and Circuit Breaker

    **Resilience Patterns:**
    - Patterns to make systems resilient to failures and prevent cascading failures.
    - Examples: Circuit Breaker, Retry, Timeout, Bulkhead, Fallback.
    
    **Circuit Breaker:**
    - Prevents continuous requests to a failing service.
    - Trips open when failures exceed a threshold.
    - Allows the system to handle failures gracefully.
    - Protects the system and prevents overloading.

4. Microservices Interview Questions

5. Load Balancing in Microservices  
   Load balancing in microservices ensures efficient traffic distribution through strategies like Round Robin or Weighted Round Robin, using hardware or software load balancers. Service discovery maintains updated lists of operational instances, while health checks ensure traffic goes only to healthy ones. Dynamic scaling adjusts resources based on demand. For consistent user experiences, session persistence maintains states. Content-based routing and global balancing enhance distribution, while monitoring tools optimize performance.

6. Service Discovery  
   Service discovery helps microservices locate and communicate with each other dynamically in a distributed environment.

7. Major Components of Kafka   
Producers, Brokers, Consumers, Topics, Partitions, Zookeeper.

8. Partition in Kafka  
A partition is a basic unit of parallelism and scalability in Kafka.

9. Zookeeper in Kafka  
Zookeeper manages and coordinates Kafka brokers, maintains metadata, leader election, etc.

10. Kafka without Zookeeper  
No, Kafka relies on Zookeeper for critical functionalities.

11. Leader and Follower in Kafka  
Leader handles read and write requests, followers replicate data.

12. Topic Replication and ISR  
Replication ensures data durability and fault tolerance.
ISR (In-Sync Replicas) are replicas that are up-to-date with the leader.

13. Consumer Group in Kafka  
A group of consumers that share the load of consuming data from topics.

14. Starting Kafka Server  
Use the `kafka-server-start` script.

15. Real-world Usages of Kafka  
 Log aggregation, real-time analytics, monitoring, data pipeline, etc.

16. Partitioning Key in Kafka  
Determines which partition data should be written to.

17. Purpose of Partitions in Kafka  
Parallelism, scalability, and data distribution.

18. RabbitMQ vs. Kafka  
RabbitMQ: Message broker, supports multiple messaging patterns.
Kafka: Distributed streaming platform, high throughput and fault tolerance.

19. Kafka Guarantees  
Message durability, fault tolerance, order preservation.

20. Unbalanced Cluster in Kafka  
Uneven distribution of partitions across brokers.
Reassign partitions or add more brokers to balance.

21. Role in Recent Project  
Producer

22. Topic Name in Recent Project  
Orders, Payments

23. Brokers, Partitions  
100, 100

24. Offset in Kafka  
A unique identifier for each message in a partition.
