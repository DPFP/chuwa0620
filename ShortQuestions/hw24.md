## 1
The volatile keyword ensures that the variable's value is not cached locally by each thread but is always retrieved from the main memory. This guarantees that all threads see a consistent view of the variable.

## 2
We can create thread by extending the Thread class, implementing Runnable and callable interface, and also Using a Thread Pool from the ExecutorService framework.

## 3
Runnable has no return and callable has return.

## 4
t.start() starts a new thread which will excute the task.
t.run() excute the task in the current thread

## 5
Runnable interface is better because it is more flexible. By implementing runnable you can still inherit from other class as runnable is an interface.

## 6
New, runnable, blocked, waiting, timed_waiting, terminated.

## 7
- wait() is used for inter-thread communication and synchronization, while sleep() is used for time management and introducing delays.
- wait() is called on an object and releases the lock, while sleep() is a static method called on the Thread class and does not release any locks.
- A thread can be woken up from the wait() state by another thread calling notify() or notifyAll(), while a thread in the sleep() state can be interrupted or naturally wakes up after the specified sleep duration.

## 8
Deadlock is a situation in concurrent programming where two or more threads are blocked indefinitely, waiting for each other to release resources or complete certain actions. It occurs when threads acquire locks on resources in such a way that they end up in a circular dependency, preventing any of them from progressing.

## 9
threads shared memonry, message passing mechanisms, and wait() & notify().

## 10
It allows one thread to wait for the completion of another thread before continuing its own execution. 

## 11
It is used to suggest to the thread scheduler that the current thread is willing to yield its current execution time to allow other threads of the same priority to run.

## 12
A thread pool is a managed pool of pre-created threads that can be used to execute tasks concurrently. Instead of creating a new thread for each task, a thread pool maintains a pool of worker threads, ready to execute tasks as they become available. This approach provides several benefits, including improved performance, better resource management, and easier control over thread execution.

## 13
The Executor Framework is a higher-level concurrency framework introduced in Java to simplify the management and execution of tasks in a concurrent environment. 

- FixedThreadPool
- CachedThreadPool
- SingleThreadExecutor

```
ExecutorService executor = Executors.newCachedThreadPool();
```

## 14
In summary, shutdown() allows the executor to finish executing the tasks that have already been submitted, while shutdownNow() attempts to abruptly stop the execution of tasks and discards pending tasks. The shutdown() method is a more graceful way of shutting down the executor, giving it a chance to complete ongoing tasks, while shutdownNow() provides a more aggressive approach for immediate termination.

## 15
Atomic classes in Java, found in the java.util.concurrent.atomic package, provide a way to perform atomic operations on variables without the need for explicit synchronization using locks or synchronized blocks. These classes guarantee that specific operations on variables are executed atomically, meaning they are indivisible and thread-safe.

Atomic classes are typically used in multi-threaded scenarios where multiple threads need to update a shared variable without explicit synchronization. They are particularly useful in situations where fine-grained locking or synchronization is not necessary, and using locks or synchronization mechanisms would introduce unnecessary overhead.

## 16
Concurrent collections, introduced in Java 5 as part of the java.util.concurrent package, are a set of thread-safe collection classes designed for concurrent programming. These collections provide thread-safe access and modification of their elements, allowing multiple threads to operate on them concurrently without explicit synchronization.

## 17
ReentrantLock, ReadWriteLock, StampedLock

## 18
- Class locks are acquired and released at the class level and apply to all instances of the class, while object locks are acquired and released at the instance level and apply to specific instances of the class.
- Class locks are held at the class level and are shared among all instances, while object locks are held at the individual instance level.

## 19
In Java, Future and CompletableFuture are classes that provide a way to represent the result of an asynchronous computation or task. They allow you to perform operations that can execute concurrently and obtain the result or status of the computation when it becomes available.

## 20
In Java, ThreadLocal is a class that provides thread-local variables. It allows you to create variables that are unique to each thread, ensuring that each thread has its own independent copy of the variable. 

## 21
Done

## 22
Done

## 23,24,25
See under Coding folder.