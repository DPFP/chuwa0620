# hw24

### 1. Explain volatile variables in java? (we also use it in Singleton)
Volatile keyword is used to declare variable that may be accessed by multiple thread. Reading and writing operation are directly executed in main memory instead of thread's local cache.

### 2. how to create a new thread(Please also consider Thread Pool case)?
We can create new thread by extending Tread class or implement the runnable interface and pass that runnable to the thread object. Thread Pool is the method for easily manage the thread collection. When a thread pool is created, just using execute() with a Runnable implementation pass in, it will create a new thread.

### 3. Difference between Runnable and Callable
Runnable does not return a result or throw any checked exception, but callable return a result or throw any checked exception.

### 4. what is the diff between t.start() and t.run()?
t.run() executed the code in the current thread, t.start() create a new thread and call run() method in the new thread.

### 5. Which way of creating threads is better: Thread class or Runnable interface?
Implementing runnable is a better way:
Implement runnable can still extend other classes and interfaces.
Implement mulitple runnable can achieve data sharing between different runnable.
Implement runnable is better for code separation.

### 6. what is the thread status?
New, Runnable, Running, Blocked/Waitting, Timed Waiting, Terminated.

### 7. difference between wait() and sleep() method
wait() is for communication from other thread but sleep() is for delay or pause of the current thread. Wait is called in a synchronized block but sleep is called without synchronization.

### 8. What is deadlock?
Deadlock is when two or more thread are blocked by waiting other thread to release resources. 

### 9. how do threads communicate with each other?
Shared Memory, message passing, Synchronization Primitives, Callbacks, Thread Signaling, Thread Joining.

### 10. what is join() method?
It is a thread synchronization mechanism that allows one thread to wait for the completion of another thread before continuing execution. 

### 11. what is yield() method
It is a thread control mechanism that suggests to the scheduler that the current thread is willing to give up its current time slot and allow other threads of the same priority to execute. 

### 12. Explain thread pool
A thread pool is a managed collection of threads that can be used to efficiently execute tasks concurrently. Instead of creating a new thread for each task, a thread pool reuses a fixed set of threads, which helps reduce the overhead of thread creation and destruction.

### 13. What is Executor Framework in Java, its different types and how to create these executors?
The Executor framework in Java is a higher-level abstraction for managing and executing tasks in a concurrent environment. It provides a set of interfaces and classes that facilitate the creation, submission, and execution of tasks by utilizing thread pools. 
Executor, ExecutorService, ThreadPoolExecutor.

### 14. Difference between shutdown() and shutdownNow() methods of executor
shutdown() stop ExecutorService from accepting new task and allow remaining taskes to finish, shutdownNow() stop ExecutorService from accepting new task and try to cancel the current tasks.

### 15. What is Atomic classes? when do we use it?
Atomic classes in Java, found in the java.util.concurrent.atomic package, provide a way to perform atomic operations on shared variables without the need for explicit synchronization using locks.

### 16. What is the cocurrent collections?
Cocurrent collections are designed for concurrent access from multiple threads. These collections offer thread-safe operations and provide high-performance access to shared data in concurrent programming scenarios.

### 17. what kind of locks you know?
ReentrantLock: one thread can have multiple locks
ReadWriteLock: only allow one thread to write and don't allow read when write. Allow multiple read when no write.
StampedLock: Allow write when read, but need to handle situation that data not consistance.

### 18. What is the difference between class lock and object lock?
class lock is a lock for a whole class, object lock is lock only for one object in the class. Class lock will affact all the instance and static method in the class, Object lock only affact that single object and allow different lock for different object.

### 19. What is future and completableFuture?
In Java, Future and CompletableFuture are classes that represent the result of an asynchronous computation or task. They provide a way to retrieve the result of a computation that is being executed in a separate thread or asynchronously.

### 20. what is ThreadLocal?
ThreadLocal is a class in Java that provides thread-local variables. A thread-local variable is a variable that is unique to each thread, meaning each thread has its own copy of the variable. ThreadLocal provides a way to store and retrieve values specific to each thread, without the need for explicit synchronization.

## Q25 completable future: a. Homework 1: Write a simple program that uses CompletableFuture to asynchronously get the sum and product of two integers, and print the results. b. Homework 2: Assume there is an online store that needs to fetch data from three APIs: products, reviews, and inventory. Use CompletableFuture to implement this scenario and merge the fetched data for further processing. (需要找public api去模拟，)i. Sign In to Developer.BestBuy.com ii. Best Buy Developer API Documentation (bestbuyapis.github.io) iii. 可以用fake api https://jsonplaceholder.typicode.com/ c. Homework 3: For Homework 2, implement exception handling. If an exception occurs during any API call, return a default value and log the exception information
Homework1
```java
import java.util.concurrent.CompletableFuture;

public class CompletableFutureExample {
    public static void main(String[] args) {
        int num1 = 5;
        int num2 = 7;

        CompletableFuture<Integer> sumFuture = CompletableFuture.supplyAsync(() -> calculateSum(num1, num2));
        CompletableFuture<Integer> productFuture = CompletableFuture.supplyAsync(() -> calculateProduct(num1, num2));

        sumFuture.thenAcceptAsync(sum -> {
            System.out.println("Sum: " + sum);
        });

        productFuture.thenAcceptAsync(product -> {
            System.out.println("Product: " + product);
        });

        // Wait for both CompletableFuture to complete
        CompletableFuture.allOf(sumFuture, productFuture).join();
    }

    public static int calculateSum(int num1, int num2) {
        return num1 + num2;
    }

    public static int calculateProduct(int num1, int num2) {
        return num1 * num2;
    }
}

```
homework2
```java
import java.util.concurrent.CompletableFuture;

public class OnlineStoreExample {
    public static void main(String[] args) {
        CompletableFuture<String> productsFuture = fetchProducts();
        CompletableFuture<String> reviewsFuture = fetchReviews();
        CompletableFuture<String> inventoryFuture = fetchInventory();

        CompletableFuture<Void> combinedFuture = CompletableFuture.allOf(productsFuture, reviewsFuture, inventoryFuture);

        combinedFuture.thenRun(() -> {
            try {
                String productsData = productsFuture.get();
                String reviewsData = reviewsFuture.get();
                String inventoryData = inventoryFuture.get();
                String mergedData = mergeData(productsData, reviewsData, inventoryData);
                System.out.println("Merged Data: " + mergedData);
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
        combinedFuture.join();
    }

    public static CompletableFuture<String> fetchProducts() {
        return CompletableFuture.supplyAsync(() -> {
            return "Products data";
        });
    }

    public static CompletableFuture<String> fetchReviews() {
        return CompletableFuture.supplyAsync(() -> {
            return "Reviews data";
        });
    }

    public static CompletableFuture<String> fetchInventory() {
        return CompletableFuture.supplyAsync(() -> {
            return "Inventory data";
        });
    }

    public static String mergeData(String productsData, String reviewsData, String inventoryData) {
        return productsData + ", " + reviewsData + ", " + inventoryData;
    }
}
```
homework3
```java
import java.util.concurrent.CompletableFuture;

public class OnlineStoreExample {
    public static void main(String[] args) {
        CompletableFuture<String> productsFuture = fetchProducts();
        CompletableFuture<String> reviewsFuture = fetchReviews();
        CompletableFuture<String> inventoryFuture = fetchInventory();

        CompletableFuture<Void> combinedFuture = CompletableFuture.allOf(productsFuture, reviewsFuture, inventoryFuture);

        combinedFuture.thenRun(() -> {
            try {
                String productsData = productsFuture.get();
                String reviewsData = reviewsFuture.get();
                String inventoryData = inventoryFuture.get();
                String mergedData = mergeData(productsData, reviewsData, inventoryData);
                System.out.println("Merged Data: " + mergedData);
            } catch (InterruptedException | ExecutionException e) {
                LOGGER.log(Level.SEVERE, "Exception occurred while fetching data", e);
            }
        });
        combinedFuture.join();
    }

    public static CompletableFuture<String> fetchProducts() {
        return CompletableFuture.supplyAsync(() -> {
            try{
                return "Products data";
            }
            catch(Exception e){
                LOGGER.log(Level.SEVERE, "Exception occurred while fetching products data", e);
                return "Default products data";    
            }
        });
    }

    public static CompletableFuture<String> fetchReviews() {
        return CompletableFuture.supplyAsync(() -> {
            try{
                return "Reviews data";
            }
            catch(Exception e){
                LOGGER.log(Level.SEVERE, "Exception occurred while fetching reviews data", e);
                return "Default reviews data";
            }
        });
    }

    public static CompletableFuture<String> fetchInventory() {
        return CompletableFuture.supplyAsync(() -> {
            try{
                return "Inventory data";
            }
            catch(Exception e){
                LOGGER.log(Level.SEVERE, "Exception occurred while fetching inventory data", e);
                return "Default inventory data";                
            }
            
        });
    }

    public static String mergeData(String productsData, String reviewsData, String inventoryData) {
        return productsData + ", " + reviewsData + ", " + inventoryData;
    }
}
```