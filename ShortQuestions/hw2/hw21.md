
# Homework21
#Chingpo Lin

-----

## Q2: What is the checked exception and unchecked exception in Java, could you give one example?

checked exception are exceptions that would check in compile time, while unchecked exception is runtime exception.

Like IOException, we would know in compile time,
but like List<String> i = null, and we do i.size() would give us exception in runtime.

---

## Q3: Can there be multiple finally blocks?

No, only one finally block is allowed.

---

## Q4: When both catch and finally return values, what will be the final result ?

if catch execute: finally block will run but return the value from catch block  
if catch not execute: return the value from finally block

---

## Q5: What is Runtime/unchecked exception ? what is Compile/Checked Exception?

checked exception are exceptions that would check in compile time, while unchecked exception is runtime exception.

---

## Q6: What is the difference between throw and throws ?

throw is used inside a method or block of code
- if use throw, it need to be followed by an instance of an exception or a subclass of "throwable"
- throw will terminate current execution and transfer to the nearest exception handler to handle the thrown exception.

throws is used in a method signature to indicate the method may throw one or more exceptions
- when a method declare throws clause, the caller should be responsible for handling or propagating the declared exceptions.

---

## Q7: Run the below three pieces codes, Noticed the printed exceptions. why do we put the Null/Runtime
exception before Exception ?

because null pointer exception is a kind of runtime exception, if we catch runtime exception first, we could not catch specific runtime exception then.

---

##Q7(2): Why finally always be executed ?

Finally is designed to contain code that always execute no matter if exception happens. It ensures certain cleanup ofr resource release operations.

---

##Q8: What are the types of design patterns in Java ?

- Creational Patterns: focus on object creation mechanism
    - Singleton Pattern
    - Factory Pattern
    - Abstract Pattern
    - Builder Pattern
    - Prototype Pattern
- Structural Patterns: handle composition of classes and objects to form larger structures
    - Adapter Pattern
    - Decorator Pattern
    - Proxy Pattern
    - Composite Pattern
    - Facade Pattern
    - Bridge Pattern
- Behavioral Patterns: focus on interaction between objects
    - Observer Pattern
    - Strategy Pattern
    - Command Pattern
    - Iterator Pattern
    - State Pattern
    - Template Method Pattern
    
---

##Q9: What are the SOLID Principles ?

solid principles are 5 design principles that help designing and structuring software systems to achieve maintainability, flexibility, and extensibility.
- Single Responsibility Principle (SRP)
    - a class should have only one reason to change
    - each class should have a single responsibility or purpose
    - high cohesion and reduces the impact of changes.
- Open-Closed Principle (OCP)
    - software entities(class, module, function) should be open for extension but close for modification
- Liskov Substitution Principle (LSP)
    - objects of superclass should be replaceable with objects of its subclasses without affecting the correctness of program.
- Interface Segregation Principle (ISP)
    - clients should not be forced to depend on interfaces they do not use.
- Dependency Inversion Principle (DIP)
    - high level module should not depend on low level module. Both should depend on abstractions
 
---

## Q10: How can you achieve thread-safe singleton patterns in Java ?

1. Eager initialization (initialize at first)
2. Lazy initialization (initialize when use) (more recommend)

first use memory but no need to load then.

---

## Q11: What do you understand by the Open-Closed Principle (OCP) ?

software entities(class, module, function) should be open for extension but close for modification.
This means we could add more functionality or behavior to a system but could not modify existing code.

---

## Q12: (SOLID-L)Liskovâ€™s substitution principle states that if class B is a subtype of class A, then object of type A may be substituted with any object of type B. What does this actually mean? (from OA ) choose your answer

1.  It mean that if the object of type A can do something, the object of type B could also be able to perform the same thing







