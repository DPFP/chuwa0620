
# Homework23
#Chingpo Lin

-----

## 1. Explain volatile variables in java? (we also use it in Singleton)

a variable declared volatile means any read or write to it will directly affect main memory and update in all thread

---

## 2. how to create a new thread(Please also consider Thread Pool case)?

1. Thread creation:
    - implements Callable<T>
    - implements Runnable
    - extends Thread
2. Thread Pool creation
    - create thread pool: ExecutorService es = Executors.newFixedThreadPool(4);
        - FixedThreadPool (fix pool)
        - CachedThreadPool (dynamic pool)
        - SingleThreadExecutor (single thread pool)
 
---

## 3.  Difference between Runnable and Callable

- runnable does not return a result while callable can

---

## 4.  what is the diff between t.start() and t.run()?

- t.start starts a new thread to execute the task(run())
- t.run() excute the task in the current thread.

---

## 5. Which way of creating threads is better: Thread class or Runnable interface?

Runnable is better because 
- runnable is interface which we can implement multiple interface in java while thread is not.
- ExcutorService and ThreadPoolExecutor work better with runnable class

---

## 6. what is the thread status?
- New
- Runnable
- Running
- Blocked/Waiting
- Timed Waiting
- Terminated

---

## 7. difference between wait() and sleep() method
- wait() is used with synchronization and require lock release while sleep() does not
- wait() waits until notified or interrupted while sleep() stop execution for a time duration

---

## 8. What is deadlock?

when two or more threads are blocked and waiting for each other to release the lock.

---

## 9. how do threads communicate with each other?

we could use multiple methods like:
- wait
- notify
- synchronized
- join
- interrupt
- ThreadLocal

---

## 10. what is join() method?

t.join() will let current thread to wait until thread t finish.

---

## 11. what is yield() method

The yield() method provides an opportunity for the other thread to run.

---

## 12. Explain thread pool

a collection of thread can be used to execute multiple tasks concurrently.

## 13. What is Executor Framework in Java, its different types and how to create these executors?

For managing and executing tasks concurrently.

- Executors.newFixedThreadPool(int nThreads): fixed task
- Executors.newCachedThreadPool(): dynatic task
- Executors.newSingleThreadExecutor(): single worker thread
- Executors.newScheduledThreadPool(int corePoolSize): this can create a thread pool which can schedule tasks to be executed periodically or after a delay

---

## 14. Difference between shutdown() and shutdownNow() methods of executor

- shutdown() allow previous tasks to finish, but prevent the executor to accept new tasks
- shutdownNow() stop the running tasks and pending tasks, and prevent the executor to accept new tasks

---

## 15. What is Atomic classes? when do we use it?

Atomic class is classes who support concurrent programming with thread-safe operations on shared variables. we use when multiple threads need read and write a shared variable concurrently.

---

## 16. What is the concurrent collections?

Same as atomic class, common concurrent collections:

- ConcurrentHashMap
- ConcurrentLinkedQueue
- ConcurrentSkipListMap
- CopyOnWriteArrayList

---

## 17. what kind of locks you know?

- ReentrantLock: a thread can acquire the lock multiple times without deadlock.
- ReadWriteLock: consists of two locks: read&write lock. if no threads hold write lock, multiple threads can acquire read lock, but only one thread can acquire the write lock.
- StampedLock: read, write, and optimistic read. It provides an optimistic read mode where multiple threads can read concurrently without acquiring the lock. If a thread wants to perform a write operation, it needs to acquire a write lock, which excludes other read and write operations.
- ReentrantReadWriteLock: allowing a thread that already holds the read lock to acquire it again. This type of lock can be useful when there are frequent read operations and rare write operations.

---

## 18. What is the difference between class lock and object lock?

- The class lock ensures that only one thread at a time can execute synchronized static methods or access static synchronized blocks in that class. It provides exclusive access to class-level resources shared among all instances of the class.
- The object lock ensures that only one thread at a time can execute synchronized instance methods or access synchronized instance blocks on that specific object. It provides exclusive access to instance-level resources of the object.

---

## 19. What is future and completableFuture?

- A Future object can be used to check if the computation is complete, retrieve the result when it becomes available, or cancel the computation.
- Based on future object, completableFuture provides a fluent and functional programming style, enabling the use of callbacks, transformations, and error handling



---

## 20. what is ThreadLocal?

- A thread-local variable is a variable that is accessible only within the context of a specific thread. Each thread accessing the variable has its own independently initialized copy of the variable.

## 22. interview questions:

- What are the benefits of using Multithreading?
   - Increase use of CPU resources and reduce costs of maintenance. 
   - Improve performance as compared to traditional parallel programs that use multiple processes. 
   
- Threads are parts of a process
   
- What’s the difference between class lock and object lock?
   - Class Lock:  These locks are achieved using the keyword ‘static synchronized’ and can be used to make static data thread-safe. It is generally used when one wants to prevent multiple threads from entering a synchronized block. 
   - Object Lock: These locks are achieved using the keyword ‘synchronized’ and can be used to protect non-static data. It is generally used when one wants to synchronize a non-static method or block so that only the thread will be able to execute the code block on a given instance of the class. 
   
- What's the difference between User thread and Daemon thread?
   - JVM (Java Virtual Machine) waits for any of the user threads to complete its tasks before terminating it. When user threads are finished, JVM terminates the whole program along with associated daemon threads. 
   -  before termination. 	JVM does not wait for daemon threads to finish their tasks before termination
   
- What is thread starvation?
   - Thread starvation is basically a situation or condition where a thread won’t be able to have regular access to shared resources and therefore is unable to proceed or make progress. This is because other threads have high priority and occupy the resources for too long. This usually happens with low-priority threads that do not get CPU for its execution to carry on. 

- What is Livelock? What happens when it occurs?
   - Similar to deadlock, livelock is also another concurrency problem. In this case, the state of threads changes between one another without making any progress. Threads are not blocked but their execution is stopped due to the unavailability of resources.
   
- What is BlockingQueue?
   - BlockingQueue basically represents a queue that is thread-safe. Producer thread inserts resource/element into the queue using put() method unless it gets full and consumer thread takes resources from the queue using take() method until it gets empty
   
- Can you start a thread twice?
   - No, it's not at all possible to restart a thread once a thread gets started and completes its execution. Thread only runs once and if you try to run it for a second time, then it will throw a runtime exception i.e., java.lang.IllegalThreadStateException. 
   
- What is ConcurrentHashMap and Hashtable? In java, why is ConcurrentHashMap considered faster than Hashtable?
   - ConcurrentHashMap and Hashtable, both are thread-safe but ConcurrentHashMap generally avoids read locks and improves performance, unlike Hashtable. ConcurrentHashMap also provides lock-free reads, unlike Hashtable. Therefore, ConcurrentHashMap is considered faster than Hashtable especially when the number of readers is more as compared to the number of writers. 
   
- 









