# HW43

### 2.What is Spring and Springboot? What is the benfits of using Srpingboot?
Spring and Spring Boot are two related frameworks in the Java ecosystem that aim to simplify and enhance the development of Java-based applications, particularly web applications. Benefit of springboot are Auto-configuration, Embedded Server, Production-Ready Features, Dependency Management, Simplified Build Process. 

### 3.What is IOC and What is DI?
IOC stand for Inverse of Control, it is a principle that developer give the control of creating object to the containner, usually framework like springboot and use the object that created by the container. This enables loose coupling between components, making the application more maintainable, testable, and flexible.

DI stand for dependencies injection which help the IOC priciple. In DI, the objects (dependencies) required by a class are "injected" into the class rather than being created by the class itself. This is typically achieved through constructor injection, setter injection, or method injection. By using DI, a class becomes less dependent on specific implementations of its dependencies, making it easier to change and test different configurations.

### 4.What is @CompnonentScan?
ComponentScan is an annotation provided by the Spring Framework that is used to enable component scanning in a Spring application. Component scanning is a process where Spring automatically detects and registers Spring-managed beans (components) in the application context without the need for explicit bean definitions.

### 5.How to define which package spring need to scan in xml and annotaiton?
In XML configuration, you can use the <context:component-scan> element to enable component scanning and specify the base package to scan.
In annotations-based configuration (using @Configuration), you can use the @ComponentScan annotation to achieve the same result.

### 6.What is @SpringbootApplication?
@SpringBootApplication is a meta-annotation provided by Spring Boot, and it is used to annotate the main class of a Spring Boot application. It combines three commonly used annotations: @SpringBootConfiguration, @EnableAutoConfiguration, and @ComponentScan.

### 7.How many ways wo can define a bean?
1.XML Configuration: This is the traditional way where you can define beans in an XML file.
```java
<bean id="exampleBean" class="com.example.ExampleBean">
    <property name="propertyName" value="propertyValue"/>
</bean>

```

2.Annotation-Based Configuration: Annotations such as @Component, @Service, @Repository, @Controller, etc., can be used to define a Spring Bean. Spring's component scanning automatically picks up these classes for dependency injection.

3.Java-Based Configuration: You can use @Configuration and @Bean annotations for defining beans in a configuration class.
@Configuration
public class AppConfig {
    @Bean
    public ExampleBean exampleBean() {
        return new ExampleBean();
    }
}

4.Auto-Configuration: In Spring Boot, depending on the dependencies in the classpath, certain beans are automatically created. For example, if Spring Boot finds HSQLDB in your classpath, it automatically configures an in-memory database.

### 8. What is default bean name for @Component and @Bean?
For @Component: When a class is annotated with @Component (or any stereotype annotation such as @Service, @Repository, @Controller, etc.), the default bean name is the class name with a lowercase initial. For example, if your class is named MyService, the default bean name would be myService.

For @Bean: When a method is annotated with @Bean, the default bean name is the method name. This is typically used inside a @Configuration class.

### 9. What is the difference between  @component and  @service , @repository?
@Component: This is a generic annotation for any Spring-managed component. If you don't know whether to use @Service or @Repository, you can use @Component.

### 10. How many annotaitons we can use to inject the bean?
@Autowired, @Inject, @Resource, @Value, @ConfigurationProperties.

### 11. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?
1. Setter Injection: This is the technique where the container calls setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.
2. Constructor Injection: This is the technique where the container invokes a constructor with a number of arguments, each representing a dependency.
3. Field Injection: This is the technique where you place the @Autowired annotation directly on the field. Spring then injects a bean into this field when it initializes the class.

Usually constructor injection is better because 
1. Immutability: With Constructor Injection, the injected dependencies can be final. Once a bean is created, its dependencies cannot change. This is good for creating immutable objects which are generally safer in a multi-threaded environment.
2. Detecting circular dependencies: If there are circular dependencies between beans, Constructor Injection will reveal this issue at application startup time by throwing a BeanCurrentlyInCreationException.
3. Null safety: With Constructor Injection, as long as the object is created successfully, you know that all of its dependencies are non-null.

### 12. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primay.
If you have multiple beans of the same type, you can use the @Primary annotation to give higher preference to a particular bean. When Spring finds more than one bean of the same type and needs to inject one, it will inject the @Primary bean. In case you don't want to use @Primary, you can use @Qualifier annotation to specify which bean to inject. @Qualifier requires you to provide the name of the bean to be injected.

### 13. What is the difference between BeanFactory and ApplicationContext in Spring?
BeanFactory: BeanFactory is the root interface for accessing a Spring bean container. It provides basic Inversion of Control (IoC) and Dependency Injection (DI) features. BeanFactory makes no special provision for enterprise-specific functionalities such as event publication, application-layer specific context like WebApplicationContext for web applications, etc. It simply manages and configures the lifecycle of Spring beans.

ApplicationContext: ApplicationContext is a sub-interface of BeanFactory. It includes all functionality of the BeanFactory and much more. Its main function is to support the creation of complex enterprise applications. It provides more enterprise-specific functionality such as the ability to resolve textual messages from a properties file, the ability to publish application events to interested event listeners, integration with Aspect-oriented programming features, and the ability to load resources in a generic fashion. The ApplicationContext also supports internationalization for handling multiple locales.

### 14.What is the Scope of a Bean?  and list the examples for each scope?
"scope" refers to the lifecycle and visibility of a bean instance in the Spring container.
1. Singleton (default): When a bean is defined as singleton, the Spring IoC container creates exactly one instance of the object defined by that bean definition. 
2. Prototype: A prototype bean will have any number of object instances but they will be different. A new instance is created every time a bean is requested or injected.
3. Request (only valid in the context of a web-aware ApplicationContext): This scopes a bean definition to an HTTP request. That is, each HTTP request will have its own instance of a bean created off the back of a single bean definition.
4. Session (only valid in the context of a web-aware ApplicationContext): Scopes a bean definition to an HTTP session. The bean is created or looked up once for each HTTP session.
5. Application (only valid in the context of a web-aware ApplicationContext): Scopes a bean definition to the lifecycle of a ServletContext. This is somewhat similar to the Singleton scope but it is scoped to the lifecycle of a ServletContext.
