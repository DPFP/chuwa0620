# HW24
**1. Explain volatile variables in java?**
In Java, the volatile keyword is used to declare variables that may be accessed by multiple threads. It ensures that the value of a volatile variable is always read from and written to the main memory, rather than being cached in a thread's local cache.

**2. How to create a new thread (Please also consider Thread Pool case)**
- Extending Thread class
- Implementing Runnable interface
- Creating a Thread using a Thread Pool:
```
ExecutorService executor = Executors.newFixedThreadPool(5);
executor.submit(new Runnable() {
    @Override
    public void run() {
        // Code to be executed in the new thread
    }
});
```

**3. Difference between Runnable and Callable**
Runnable is used for tasks that do not produce a result or throw checked exceptions, while Callable is used for tasks that can return a result or throw checked exceptions.

**4. What is the diff between t.start() and t.run()**
t.start() creates a new thread and runs the target function concurrently, while t.run() executes the target function synchronously in the current thread. 

**5. Which way of creating threads is better: Thread class or Runnable interface?**
In general, the Runnable interface is often preferred over extending the Thread class because it promotes better separation of concerns and improves code flexibility. By implementing Runnable, you can design your class hierarchy more freely, implement other interfaces, or extend other classes while still being able to create threads.

**6. What is the thread status?**
- NEW: The thread is in a new state if it has been created but has not yet started its execution.
- RUNNABLE: A thread is in the runnable state if it is eligible to run, but it may not be currently executing. It could be executing, waiting for its turn on the CPU, or waiting for a resource to become available.
- BLOCKED: A thread is in the blocked state when it is waiting to acquire a monitor lock to enter a synchronized block or method. It is blocked because another thread currently holds the lock.
- WAITING: A thread is in the waiting state when it is waiting indefinitely for another thread to perform a particular action. It can occur, for example, when a thread calls the Object.wait() method without a timeout.
- TIMED_WAITING: This state is similar to the waiting state, but the thread is waiting for a specific amount of time. It can occur when a thread calls methods like Thread.sleep(long millis) or Object.wait(long millis).
- TERMINATED: A thread is in the terminated state when it has completed its execution and has exited.

**7. Difference between wait() and sleep() method**
 wait() is used for inter-thread communication, while sleep() is used for introducing delays or scheduling tasks. wait() is always called on an object within a synchronized block, and the thread waits until it is notified. On the other hand, sleep() is called directly on a thread and causes the thread to pause for the specified time. 
 
**8. What is deadlock?**
In Java, deadlock refers to a situation where two or more threads are blocked forever, waiting for each other to release resources that they currently hold. This situation leads to a state where no progress can be made, and the application appears to be frozen.

**9. How do threads communicate with each other?**
- Synchronization: Java provides the synchronized keyword and Lock objects to create mutually exclusive regions of code. By synchronizing methods or blocks, threads can coordinate their access to shared resources. This ensures that only one thread can execute the synchronized code at a time, preventing race conditions and ensuring thread-safe communication.

- Wait and Notify: Threads can use the wait() and notify() (or notifyAll()) methods of the Object class to implement more advanced communication patterns. A thread can call wait() to voluntarily give up the monitor of an object and enter a waiting state until another thread calls notify() (or notifyAll()) on the same object to wake up the waiting thread.

- Blocking Queues: Java provides the BlockingQueue interface and its implementations, such as ArrayBlockingQueue and LinkedBlockingQueue. These data structures allow threads to communicate by adding elements to a queue (producer) and removing elements from the queue (consumer). If the queue is empty, the consumer thread blocks until an element becomes available, enabling synchronization between threads.

- Joining Threads: A thread can wait for another thread to complete its execution by using the join() method. By calling join() on a thread, the invoking thread will block until the joined thread finishes. This allows threads to synchronize their execution and coordinate their activities.

- Shared Data: Threads can communicate by accessing shared data. By sharing data through variables or objects, one thread can modify the data, and another thread can read that data. However, synchronization or other mechanisms should be used to ensure proper thread safety and avoid data races.

**10. What is join() method?**
It allows one thread to wait for the completion of another thread. It is used to achieve thread synchronization, where one thread must wait for another thread to finish its execution before proceeding.

**11. What is yield() method?**
The yield() method is a static method defined in the Thread class that allows a running thread to voluntarily pause its execution and give other threads an opportunity to run. When a thread calls yield(), it indicates that it is willing to yield its current use of the processor. 

**12. Explain thread pool**
In Java, a thread pool is a collection of pre-initialized threads that are ready to perform tasks. It is a useful mechanism for managing and reusing threads.

When a task needs to be executed, it is submitted to the thread pool, and one of the idle threads from the pool is assigned to perform the task. Once the task is completed, the thread is returned to the pool and can be used for executing other tasks.

The main advantage of using a thread pool is that it avoids the overhead of creating and destroying threads for each task, which can be expensive. By reusing threads, the thread pool can save time and system resources. Additionally, the number of threads in the pool can be controlled, preventing the application from creating an excessive number of threads and potentially overloading the system.

**13. What is Executor Framework in Java, its different types and how to create these executors?**
The Executor Framework in Java provides a way to manage and control the execution of tasks asynchronously. It simplifies the process of managing threads, thread pools, and thread scheduling. 

- ThreadPoolExecutor: The most commonly used executor, which maintains a pool of worker threads and allows for efficient reuse of threads. It provides methods to configure the size of the thread pool, the queue for holding tasks, and the policy for creating new threads when the pool is saturated.

- ScheduledThreadPoolExecutor: Extends ThreadPoolExecutor and provides scheduling capabilities. It can schedule tasks to run at a specific time or with a fixed delay between executions.

- CachedThreadPool: A dynamically sized thread pool that creates new threads as needed and reuses idle threads. It does not have a maximum limit on the number of threads, so it can potentially create a large number of threads if tasks are submitted faster than they can be executed.

- FixedThreadPool: A thread pool with a fixed number of threads. Once all the threads are busy, any additional tasks are placed in a queue and wait for a thread to become available.

**14. Difference between shutdown() and shutdownNow() methods of executor**
shutdown() provides a graceful shutdown where submitted tasks are allowed to complete, while shutdownNow() attempts to forcefully terminate the executor by canceling running tasks and returning pending tasks. The choice between the two methods depends on the specific requirements and behavior desired for your application.

**15. What is Atomic classes? when do we use it**
In Java, the Atomic classes are a set of classes that provide atomic operations on variables without the need for explicit synchronization. 

You can use Atomic classes when you have a shared variable that may be accessed and modified by multiple threads simultaneously. By using Atomic classes, you can avoid the need for explicit synchronization mechanisms like synchronized blocks or volatile variables.

**16. What is the cocurrent collections**
They are a set of thread-safe data structures that are designed to be used in concurrent programming environments, where multiple threads are accessing and modifying shared data concurrently. Some of the commonly used concurrent collection classes in Java are:
- ConcurrentHashMap
- ConcurrentLinkedQueue
- CopyOnWriteArrayList
- ConcurrentSkipListMap and ConcurrentSkipListSet

**17. What kind of locks you know?**
- synchronized: Java provides built-in synchronization through the synchronized keyword. You can use it to create synchronized blocks or methods to enforce mutual exclusion. When a thread enters a synchronized block or method, it acquires the lock associated with the object and releases it when it exits.

- ReentrantLock: This is a class from the java.util.concurrent.locks package that provides an alternative to synchronized blocks. ReentrantLock implements the Lock interface and offers additional features such as fairness, reentrant locking, and the ability to interrupt waiting threads.

- ReadWriteLock: Also from the java.util.concurrent.locks package, ReadWriteLock provides a higher-level locking mechanism that allows multiple threads to read a shared resource simultaneously, while ensuring exclusive access for writing. It consists of two locks, a read lock and a write lock.

- StampedLock: Introduced in Java 8, StampedLock is an advanced lock that supports three modes: read, write, and optimistic read. It provides a way to optimize read operations by allowing them to proceed concurrently with ongoing write operations, under certain conditions.

- Condition: The Condition interface, also part of the java.util.concurrent.locks package, allows threads to wait for a certain condition to be met. It is typically used in conjunction with locks such as ReentrantLock. The lock's Condition object is obtained using the newCondition() method.

**18. What is the difference between class lock and object lock?**
 The primary difference between class-level synchronization (class lock) and instance-level synchronization (object lock) in Java is the level at which the lock is acquired. Class-level synchronization locks the entire class, preventing concurrent access to synchronized methods or blocks across all instances of that class. Instance-level synchronization locks a specific instance, allowing synchronized methods or blocks to be accessed concurrently across different instances, but not on the same instance by multiple threads simultaneously.
 
**19. What is future and completableFuture?**
Future and CompletableFuture are classes that provide a way to represent the result of an asynchronous computation. They are used to handle tasks that may take some time to complete, allowing you to perform other operations in the meantime.

Both Future and CompletableFuture provide ways to handle asynchronous computations, but CompletableFuture offers more flexibility and functionality compared to the basic capabilities provided by Future.

**20. What is ThreadLocal?**
ThreadLocal is a class that provides thread-local variables. It allows you to create variables that are unique to each thread. Each thread that accesses a ThreadLocal variable has its own, independently initialized copy of that variable.

When you create a ThreadLocal variable, you can set its initial value using the set() method. Each thread can then access its own copy of the variable using the get() method. The ThreadLocal class ensures that each thread sees only its own value, regardless of what other threads may be setting or getting.

The primary use of ThreadLocal is to maintain thread-specific data, where each thread requires its own instance of the data. It is commonly used in multi-threaded applications where data needs to be isolated per thread.

**22. Some interview Questions**
 Can you start a thread twice?
No, it's not at all possible to restart a thread once a thread gets started and completes its execution. Thread only runs once and if you try to run it for a second time, then it will throw a runtime exception i.e., java.lang.IllegalThreadStateException. 

What is thread starvation?
Thread starvation is basically a situation or condition where a thread won’t be able to have regular access to shared resources and therefore is unable to proceed or make progress. This is because other threads have high priority and occupy the resources for too long. This usually happens with low-priority threads that do not get CPU for its execution to carry on. 
