### HW4

1. In Java, the "volatile" keyword is used to indicate that a variable may be modified by multiple threads, and its value should always be read from and written to main memory, bypassing any thread-local caches. This ensures that changes made by one thread are immediately visible to other threads, preventing inconsistent or stale values.
2. In Java, you can create a new thread by either extending the Thread class or implementing the Runnable interface. If you choose to extend the Thread class, you override the run() method to define the code that will be executed in the new thread. If you implement the Runnable interface, you need to provide an implementation for the run() method and then pass an instance of your Runnable implementation to a Thread object. Finally, you call the start() method on the Thread object to begin the execution of the new thread.
3. Runnable return void, but Callable return a result.
4. In summary, t.start() creates a new thread and invokes the run() method of that thread in parallel with the current thread, enabling concurrent execution. On the other hand, t.run() directly calls the run() method within the current thread itself, leading to sequential execution without creating a new thread.
5. Both creating threads by extending the Thread class and implementing the Runnable interface have their own advantages and considerations. However, in general, implementing the Runnable interface is often preferred over extending the Thread class.
6. New, Runnable, Blocked/Waiting, Timed Waiting, Terminated.
7. The wait() method is a method of the Object class and is used for inter-thread communication, allowing a thread to voluntarily release the lock and wait for another thread to notify it. On the other hand, the sleep() method is a method of the Thread class and causes the currently executing thread to pause for a specified duration, without releasing any locks, allowing for time-based delays or pauses in the execution of a thread.
8. Deadlock refers to a situation in multi-threaded programming where two or more threads are blocked indefinitely, each waiting for the other to release a resource that they possess. As a result, all threads involved are unable to proceed, leading to a program's halt. Deadlocks commonly occur due to improper resource competition or incorrect usage of thread synchronization mechanisms.
9. Shared memory, Message Passing, signals, callbacks.
10. The join() method is a method of the Thread class in Java that allows one thread to wait for the completion of another thread. When a thread calls join() on another thread, it suspends its own execution until the joined thread finishes its execution or a specified timeout occurs.
11. The yield() method is a method of the Thread class in Java that suggests the scheduler to give up the current thread's execution time and allow other threads of the same priority to run. When a thread calls yield(), it voluntarily relinquishes the CPU and goes back to the runnable state, giving other threads a chance to execute. However, there is no guarantee that the yield() call will actually cause the thread to immediately switch to another thread.
12. A thread pool is a collection of pre-initialized threads that are ready to perform tasks. Instead of creating a new thread for each task, a thread pool reuses existing threads, improving efficiency and reducing the overhead of creating and destroying threads.
13. The Executor Framework in Java provides a higher-level abstraction for executing tasks asynchronously. It includes several types of executors, such as ThreadPoolExecutor, ScheduledThreadPoolExecutor, and ForkJoinPool, each suited for different task scheduling and execution requirements.To create these executors, you can use the Executors class, which provides factory methods. For example, you can create a ThreadPoolExecutor with a fixed number of threads using Executors.newFixedThreadPool(int nThreads), or a ScheduledThreadPoolExecutor with a specified core pool size using Executors.newScheduledThreadPool(int corePoolSize).
14. In summary, shutdown() provides a graceful shutdown by allowing ongoing tasks to complete, while shutdownNow() forcefully terminates the ExecutorService by interrupting tasks and discarding pending tasks.
15. Atomic classes in Java, such as AtomicInteger, AtomicBoolean, and AtomicReference, provide a way to perform atomic operations on shared variables without the need for explicit synchronization. Atomic classes are used when you need to perform operations on shared variables in a multi-threaded environment without the risk of race conditions or data inconsistencies. They are particularly useful in scenarios where multiple threads might simultaneously access and modify the same variable, ensuring that the variable's value remains consistent and predictable.
16. Concurrent collections are specialized data structures in Java that are designed to be used in multi-threaded environments. They provide thread-safe operations and efficient concurrent access to the underlying data.
17. - ReentrantLock: A reentrant lock allows a thread to acquire the lock multiple times before releasing it. It provides features like fairness, allowing the lock to be acquired in the order of request, and the ability to interrupt a thread waiting for the lock.
    - ReadWriteLock: A read-write lock allows multiple threads to acquire the lock for reading simultaneously, as long as no threads are currently holding the write lock. This allows for efficient concurrent read access while maintaining exclusive write access.
    - StampedLock: StampedLock is an advanced lock introduced in Java 8. It provides three modes: read, write, and optimistic. Optimistic reads allow for fast, non-blocking access to the shared data, with the possibility of validation and conversion to a full read or write lock if necessary.
18. In summary, object locks provide synchronization at the instance level, ensuring exclusive access to synchronized code blocks for each object instance. Class locks provide synchronization at the class level, allowing only one thread to execute synchronized code blocks or methods across all instances of the class.
19. In Java, a Future represents the result of an asynchronous computation. It provides a way to check if the computation is complete, retrieve the result when it becomes available, and handle exceptions that might have occurred during the computation.CompletableFuture, introduced in Java 8, is an enhanced version of Future that provides additional features and flexibility. It extends the functionality of Future by allowing you to chain multiple asynchronous operations together, apply transformations and combine results, and explicitly control the completion of the Future.
20. ThreadLocal is a class in Java that provides thread-local variables. A thread-local variable is a variable that is accessible only to the thread that creates and owns it. Each thread accessing a thread-local variable has its own independent copy of that variable, which is not shared with other threads.
