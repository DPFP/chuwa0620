## 1
See Annotation.md.

## 2
See hw41 PR.

## 3
Done.

## 4
JPA stands for Java Persistence API. It is a specification in Java that defines a set of interfaces and annotations for managing relational data in a Java application. JPA provides a standard way to interact with relational databases using object-oriented programming principles, allowing developers to work with entities (Java objects) rather than writing raw SQL queries.

Hibernate, on the other hand, is an open-source implementation of the JPA specification. It is one of the most popular and widely used Object-Relational Mapping (ORM) frameworks in the Java ecosystem. Hibernate enables developers to map Java objects to database tables and provides automatic persistence, which means it takes care of the storage and retrieval of Java objects from the database without the need for manual SQL coding.

## 5
Hikari is a JDBC DataSource implementation that provides a connection pooling mechanism.
In conclusion, connection pooling is a valuable technique in Java applications that helps enhance performance, resource management, and scalability when interacting with databases. By efficiently managing connections to the database, connection pooling reduces overhead and contributes to a more responsive and robust application.

## 6
THey are annotations used in the context of Object-Relational Mapping (ORM) frameworks like Java Persistence API (JPA) or Hibernate. They define the relationships between entities (Java classes representing database tables) to establish associations between different tables in a relational database.

```
@Entity
public class Author {
    // ...

    @OneToMany(mappedBy = "author") // "author" is the field in the Book class representing the relationship
    private List<Book> books;

    // getters and setters
}

@Entity
public class Book {
    // ...

    @ManyToOne // Many books can belong to one author
    @JoinColumn(name = "author_id") // "author_id" is the foreign key column in the Book table
    private Author author;

    // getters and setters
}

```

## 7
In the context of Java Persistence API (JPA) or Hibernate, cascade and orphanRemoval are options that can be used in association mappings to define how changes to one entity (parent) affect related entities (children) when performing operations like persisting, updating, or deleting.

CascadeType.ALL is one of the cascade types available in JPA/Hibernate. When you specify CascadeType.ALL, it means that all operations performed on the parent entity should be cascaded to the associated child entities.

orphanRemoval is a separate option that can be used alongside the cascade types. When orphanRemoval is set to true, it means that if a child entity is removed or disassociated from its parent entity (e.g., by setting the reference to null or removing it from the parent's collection), it should be automatically deleted from the database.

Persist, Merge, Refresh, Remove, Detach, All.

## 8
In the context of Java Persistence API (JPA) or Hibernate, fetch = FetchType.LAZY and fetch = FetchType.EAGER are options used to define how related entities should be fetched when accessing an association between entities.

FetchType.LAZY:
When you specify FetchType.LAZY, it means that the related entity or collection will not be loaded from the database until it is explicitly accessed by the application code. In other words, the related entity is loaded lazily on-demand when it is needed.

Lazy loading can help improve performance by reducing the initial query's complexity and the data transferred over the network. Use FetchType.LAZY when the related entities are not always needed or when the associated data is large.


FetchType.EAGER:
On the other hand, when you specify FetchType.EAGER, it means that the related entity or collection will be immediately fetched from the database along with the owning entity. This means that the related entity is eagerly loaded when the owner entity is retrieved.

FetchType.EAGER fetches the related entities immediately with the owning entity. It is suitable when you know that you will always need the related entities whenever you fetch the owner entity. 

## 9
JPA follows a set of naming conventions to automatically map Java class and field names to corresponding database table and column names. These naming conventions help reduce the need for explicit mappings and make it easier to work with JPA entities. By following these conventions, developers can create a seamless mapping between their Java classes and the database schema without much additional configuration.


Use Keywords such as find, by, and, or; assoicated with column names.
No we do not need to implement it.

## 10
See authorRepository.

## 11,12
Optional

## 13
Done.

## 14
JPQL stands for Java Persistence Query Language. It is a query language defined by the Java Persistence API (JPA) specification for querying data from relational databases in a database-independent manner. JPQL allows developers to write database queries using entity and attribute names instead of native SQL queries.

## 15
@NamedQuery and @NamedQueries are annotations provided by the Java Persistence API (JPA) to define named queries for entities. Named queries allow you to pre-define and name specific JPQL (Java Persistence Query Language) queries in your entity classes or in XML mapping files. By using named queries, you can easily reuse these queries in your code and keep the query definitions centralized.

## 16
With @Query, you can write custom JPQL or native SQL queries to fetch data from the database. The annotation is applied to a method in a repository interface, and you specify the query as a parameter to the annotation.

## 17
HQL (Hibernate Query Language) and Criteria Queries are two different query approaches provided by Hibernate, which is an Object-Relational Mapping (ORM) framework for Java, built on top of the Java Persistence API (JPA).

## 18
EntityManager is a central interface in the Java Persistence API (JPA) used for managing and interacting with JPA entities in a Java application. It is a part of the JPA specification and acts as a bridge between the application code and the underlying relational database.

## 19
The SessionFactory is a central and heavyweight object in Hibernate. It is responsible for creating and managing database connections, configuring Hibernate mappings, and creating Session instances. The SessionFactory is typically created once during the application's startup and shared across the entire application.

A Session represents a single-unit-of-work with the database. It is a lightweight and non-thread-safe object used to perform database operations, such as saving, retrieving, updating, and deleting entities.
The Session is obtained from the SessionFactory, and it represents a logical connection to the database. Each Session instance maintains its own transaction context. Multiple sessions can exist in the same application, and each session corresponds to a separate database transaction.

## 20
A transaction is a fundamental concept in database management systems that ensures the integrity and consistency of data when performing multiple related database operations. In the context of database transactions, a transaction represents a sequence of one or more database operations that must be executed as a single, atomic unit of work.

In the context of Hibernate or JPA, transactions are managed by the EntityManager or Session.

## 21, 22
Hibernate caching is a mechanism that improves the performance of database operations by reducing the number of trips to the database. It allows Hibernate, an Object-Relational Mapping (ORM) framework, to store frequently accessed data in memory, which can be quickly retrieved without the need to execute database queries repeatedly.

The first-level cache is associated with the Session in Hibernate. It is enabled by default and stores the objects that have been retrieved or persisted within the current session. Whenever an entity is retrieved using Session.get() or Session.load(), Hibernate places the entity into the first-level cache. Subsequent requests for the same entity within the same session do not trigger additional database queries; instead, the cached copy is returned, improving query performance.

The second-level cache is a shared cache that spans across multiple Session instances in a Hibernate session factory. Unlike the first-level cache, which is limited to a single session, the second-level cache is shared among all sessions in an application. It stores frequently accessed entities, query results, and collection data across sessions. Popular second-level cache providers are Ehcache, Infinispan, and Hazelcast.

Enabling and configuring the second-level cache can be done using various configuration options and annotations in Hibernate. It helps in reducing the database load and improving the overall application performance.

## 23
@Transactional is an annotation used in Java to define the scope of a transaction for methods in a Spring application. It is part of the Spring Framework's declarative transaction management feature, which allows developers to manage transactions without explicitly writing transactional code.

When you annotate a method with @Transactional, Spring automatically handles the transaction management for that method. Spring will start a new transaction before the method is executed and commit the transaction after the method completes successfully. If an exception is thrown within the method, the transaction will be rolled back, ensuring data integrity.

## 24
```
public interface Shape {
    void draw();
}


public class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Circle.");
    }
}

public class Square implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Square.");
    }
}

public class ShapeFactory {
    public Shape createShape(String type) {
        if (type.equalsIgnoreCase("circle")) {
            return new Circle();
        } else {
            return new Square();
        } 
        return null; // Return null if the type is not recognized.
    }
}

```