# Spring Data

## Q4 what is JPA? and what is Hibernate?

JPA is Java Persistence API, it is a standard specification provided by Java for object-relational mapping(ORM) in Java applications. It allows developers to manage relational data in databases using object-oriented paradigms, making it easier to interact with databases and perform CRUD operations without writing raw SQL queries.

Hibernate is an open-source object-relational mapping(ORM) framework for Java. It implements the JPA specification and provides additional features beyond the standard JPA.

## Q5 What is Hiraki? what is the benefits of connection pool?
It is a popular and high-performance JDBC connection pool library for Java applications. Connection pool is a technique used to manage and reuse database connections in a more efficient way. Instead of opening a new database connection every time a client requests access to the database, a connection pool maintains a pool of pre-established database connections that can be reused.

## Q6 What is the  @OneToMany, @ManyToOne, @ManyToMany? write some examples.
In JPA, those annotations are used to define relationships between entities in a relational databases, representing one-to-many, many-to-one and many-to-many relationships.

```Java
@Entity
public class Author {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    // One author can have many books
    @OneToMany(mappedBy = "author", cascade = CascadeType.ALL)
    private List<Book> books;

    // Getters and setters

@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String title;

    // Many books can have one author
    @ManyToOne
    @JoinColumn(name = "author_id", nullable = false)
    private Author author;

    // Getters and setters
}
}
```

## Q7 What is the  cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?
'cascade' property specifies the operations that should be cascaded from the parent entity to its associated entities. 'CascadeType.ALL' indicates that all operationsï¼ˆpersist, remove, merge, refresh and detach) should be cascaded from the parent entity to its associated entities.

'orphanRemoval' property is a boolean attribute that is used to control the removal of orphaned associated entities. An orphaned entity is an entity that is no longer associated with any parent entity. When 'orphanRemoval' is set ot 'true' means when an entity is removed from the parent entity's collection, it will also be deleted from the database.

## Q8 What is the  fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?
'FetchType.LAZY' means the entities are loaded from the database only when accessed for the first time. Lazy loading delays the loading of associated entities until they are explicitly requested through getter methods or when navigating the relationship. 

'FetchType.EAGER' means the entities are loaded immediately along with the parent entity during the initial query. Eager loading ensures that all related entities are available without requiring additional queries when accessed. This approach aims to fetch all related data upfront, which can be beneficial for specific use cases where all the associated data is commonly needed together.


## Q9 What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?
JPA provides a naming convention for generating queries based on the method names in the repository interface. By following this convention, you can create custom queries without writing explicit JPQL or SQL statements. The naming convention is as follows:

1. Prefix: the method name starts with 'findBy', 'getBy', 'readBy' or 'queryBy' followed by the property or properties you want to query on. For example, 'findByFirstName', 'getByLastName', 'readByEmail'.

2. Properties: You can specify one or more properties in the method name that correspond to the entity's attribtes you want to query. These properties should be written in CamelCase.

3. Combining Properties: If you need to query on multiple properties, you can concatenate them using the 'And', 'Or' or 'Not' keywords. For example, 'findByFirstNameAndLastName', 'findByAgeOrEmail', 'findByLastNameNot'.

4. Keywords: You can use keywords like 'IgnoreCase', 'OrderBy', 'In', 'NotIn' to modify the query behavior.

## Q14 What is JPQL?
JPQL stands for Java Persistence Query Language. It is a query language defined by the Java Persistence API for querying and manipulating entities in a database-agnostic manner.

## Q15 What is @NamedQuery and @NamedQueries?
@NamedQuery is used to define a single named query for an entity. You can annotate your entity class with '@NamedQuery', providing a name for the query and the JPQL query string.
```Java
@Entity
@NamedQuery(name = "User.findByAge", query = "SELECT u FROM User u WHERE u.age > :minAge")
public class User {
    // Entity code here
}
```

@NamedQueries is used to define multiple named queries for an entity. It allows you to group several named queries together using an array of '@NamedQuery' annotations.

```Java
@Entity
@NamedQueries({
    @NamedQuery(name = "User.findByAge", query = "SELECT u FROM User u WHERE u.age > :minAge"),
    @NamedQuery(name = "User.findByEmail", query = "SELECT u FROM User u WHERE u.email = :email")
})
public class User {
    // Entity code here
}
```

## Q16 What is @Query? In which Interface we write the sql or JPQL?
@Query is an annotation in Spring Data JPA that allows you to define custom queries directly in Spring Data repository interface. With '@Query', you can write SQL queries or JPQL queries to retrieve data from the database in a more flexible and explicit manner.

```Java
public interface UserRepository extends JpaRepository<User, Long> {

    @Query(value = "SELECT * FROM users u WHERE u.age > :minAge", nativeQuery = true)
    List<User> findUsersAboveMinAge(@Param("minAge") int minAge);
}
```
## Q17 What is HQL and Criteria Queries?
HQL (Hibernate Query Language) is a query language specific to Hibernate, which is an ORM (Object-Relational Mapping) framework for Java.

Criteria Queries is another approach for constructing queries in Hibernate (and JPA). It provides a programmatic way to build queries using a type-safe API. Instead of writing queries as strings like in HQL or JPQL, you use the Criteria API to build queries dynamically using Java code.

## Q18 What is EnityManager?
It is a core interface in JPA that serves as the primary interface for interacting with entities and managing their lifecycle within the context of a JPA-enabled application. It is responsible for persisting, retrieving, updating and deleting entities to and from the underlying relational database.

## Q19 What is SessionFactory and Session?
SessionFactory is a heavy-weight object in Hibernate for creating Session instance. It provide the database connection cache pool, help to optimize the efficiency and avoid to creating duplicate connections.

Session is light-weight object for interacting with the database, executing the CRUD and query. Every session corresponds to a database transaction, which means any changes made to the objects within the session will be persisted in the database when the transaction is committed.
## Q20 What is Transaction? how to manage your transaction?
Transaction is a unit of work that represents a sequence of database operations treated as a single entity. It ensures data consistency and integrity, rolling back if any part fails.

To manage the transactions, we can use either programmatic or declarative approaches. In the programmatic approach, we manually handle transactions using code, while in the declarative approach, we use annotations or configuration to define transaction boundaries, letting the framework to handle the rest.

## Q21 What is hibernate Caching?
Hibernate caching is a mechanism that stores frequently accessed data in memory to improve application performance. It reduces the need to repeatedly fetch data from the database, speeding up application response times. Hibernate provides different levels of caching, including first-level cache(Session cache) and second-level cache(global cache), which can be configured to suit specific application requirements.

## Q22 What is the difference between first-level cache and second-level cache?
First level cache is associated with the Session and stores objects retrieved during the current session. It improves performance by reducing redundant database queries for the same data within the session.

Second level cache is shared across multiple sessions and stores objects globally. It helps optimize performance by reducing database hits for commonly accessed data, benefiting the entire application.

## Q23 How do you understand @Transactional? 
@Transactional is an annotation used in Spring Framework to manage transactions in a declarative manner. When applied to a method or class, it defines the transactional boundary, ensuring that the method's database operations are treated as a single unit of work. If the method completes successfully, the transaction is committed, and if an exception occurs, the transaction is rolled back, maintaining data consistency and integrity.

## Q24 Write a simple factory design pattern
```Java
public interface Shape {
    void draw();
}

public class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Circle");
    }
}

public class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Rectangle");
    }
}


public class ShapeFactory {
    // Factory method to create Shape objects
    public static Shape createShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }

        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        }

        return null;
    }
}


public class Main {
    public static void main(String[] args) {
        // Create a Circle
        Shape circle = ShapeFactory.createShape("CIRCLE");
        circle.draw();

        // Create a Rectangle
        Shape rectangle = ShapeFactory.createShape("RECTANGLE");
        rectangle.draw();
    }
}
```

# Exception-validation

## Q2 what is the @configuration and @bean?
@Configuration is used to mark a class as a configuration class, indicating that it contains bean definitions. Spring scans @Configuration classes to create and manage beans.

@Bean is used within @Configuration class to define a Spring bean. Methods annotated with @Bean create and configure the bean instance. The returned object is registered as a Spring bean in the application context.

## Q3 How do you handle the exception in Spring?
Use @ExceptionHandler annotation, which allows us to define methods to handle specific types of exceptions. Additionally, we can use the global exception handling mechanism by implementing the HandlerExceptionResolver interface or using the @ControllerAdvice annotation to create global exception handlers for the entire application.

## Q4 How do you do the validations in Spring? And list some validation annotaitons you know.
We can use @Valid annotation along with the @RequestBody or @ModelAttribute annotations in the controller methods. Spring offers several validation annotations, including @NotNull, @NotEmpty, @Size, @Min, @Max, and @Pattern, to ensure that the incoming data meets the required constraints.

## Q5 What is the actuator?
Actuator is a module in Spring Boot that provides production-ready features to monitor and manage the application. It offers endpoints for health checks, metrics, environment properties, logging and more. Actuator is a valuable tool for administrators to monitor and troubleshoot the application in real-time.