4. JPA is a Java specification that gives some functionality and standard to ORM tools. It is used to examine, control, and persist data between Java objects and relational databases. As it is a specification of Java, JPA does not conduct any functioning by itself. Therefore, it needs implementation. Hence, for data persistence ORM tools like Hibernate implements JPA specifications.
5. HikariCP is solid high-performance JDBC connection pool. A connection pool is a cache of database connections maintained so that the connections can be reused when future requests to the database are required. Connection pools may significantly reduce the overall resource usage. 
6. What is the @OneToMany, @ManyToOne, @ManyToMany? There are annotation to indicate the relation between fields in two forms. 
7. cascade=CascadeType.ALL means any changes in current field will cause the changes of its related field
   eg. CascadeType.PERSIST: cascade type presist means that save() or persist() operations cascade to related entities.
CascadeType.MERGE: cascade type merge means that related entities are merged when the owning entity is merged.
8.  fetch = FetchType.LAZY only return current row. fetch = FetchType.EAGER return related row as well
9.  Follow the rule of keyword and columnname. eg.findByLastnameOrFirstname(a, b). There are a list of keywords we can reference to.
14. JPQL is Java Persistence Query Language defined in JPA specification. It is used to create queries against entities to store in a relational database. JPQL is developed based on SQL syntax. But it won’t affect the database directly.
15. @NamedQuery: This annotation is used to define a static query at the entity level. This means the query is defined in your Entity class and can be referenced by name elsewhere in your code. It helps in improving the readability of the code. 
16. Query： allows you to write your own custom queries directly in your repository interface, using either native SQL or JPQL (Java Persistence Query Language). The queries can be part of your method declarations.
17.  HQL is an object-oriented query language, similar to SQL, but instead of operating on tables and columns, HQL works with persistent objects and their properties.

18. EntityManager is one of the core interfaces in the Java Persistence API (JPA). It's used to manage the persistence of entities, i.e., Java objects that represent rows in a relational database table.
19.  It's a factory for Session objects. An instance of SessionFactory is usually created at application startup and kept for later use. It is thread-safe and serves as an object-level cache.
20.  A Session is a single-threaded unit of work with the database and holds a mandatory (first-level) cache of persistent data.
21.  a transaction is a single logical unit of work that consists of one or more operations, which are either all performed or none of them is performed, in order to maintain the integrity of the data
22.  First-level cache: This is associated with the Session object. When you open a session and load some data, that data is first put in the first-level cache. It's accessible as long as the session is open. 
Second-level cache: This cache is associated with the SessionFactory object. When you load some data, if that data isn't in the first-level cache and isn't in the second-level cache, then a database query is executed and the data is stored in both caches

##Exception-Validation
2.  Spring Configuration annotation indicates that the class has @Bean definition methods. So Spring container can process the class and generate Spring Beans to be used in the application. Spring @Configuration annotation allows us to use annotations for dependency injection.
   @Bean: When JavaConfig encounters such a method, it will execute that method and register the return value as a bean within a BeanFactory. By default, the bean name will be the same as the method name (see bean naming for details on how to customize this behavior). 
3. use globalexception handler 
4. use validation dependency eg.@NotEmpty @valid
5. Actuator is mainly used to expose operational information about the running application — health, metrics, info, dump, env, etc. It uses HTTP endpoints or JMX beans to enable us to interact with it. Once this dependency is on the classpath, several endpoints are available for us out of the box.