1. see annotations.md
2. Post a Comment, Edit and delete comments, Comment likes and upvotes, timestamps and sortings, notifications
3. select POST and write JSON type body as request body
4. JPA (Java Persistence API) is a Java specification that provides a standard way to interact with relational databases from Java applications. It defines a set of interfaces and annotations to manage object-relational mapping (ORM), allowing developers to map Java objects to database tables and perform CRUD (Create, Read, Update, Delete) operations without writing native SQL queries. Hibernate, on the other hand, is an open-source ORM framework that implements the JPA specification. It simplifies database access by automatically translating Java objects into database records and vice versa. Hibernate handles the complexities of managing the database connection, generating SQL queries, and optimizing database interactions, making it easier for developers to work with databases in Java applications. In summary, JPA is a Java specification that defines ORM interfaces and annotations, while Hibernate is an ORM framework that implements the JPA specification, offering a convenient way to manage database operations in Java applications.
5. Connection pooling,
   1. Performance Improvement
   2. Resource Management
   3. Connection Reuse
   4. Connection Recycling
   5. Cost-effctive
   6. Concurrency Control
6. @OneToMany, @ManyToOne, and @ManyToMany are annotations commonly used in Java ORM frameworks, such as JPA (Java Persistence API) and Hibernate, to establish relationships between entities in a database. These annotations help define how entities are related to each other, allowing for easy mapping of complex database relationships into Java objects.

- @OneToMany

  ```
    @Entity
    public class Author {
        @Id
        @GeneratedValue
        private Long id;

        private String name;

        @OneToMany(mappedBy = "author")
        private List<Book> books;

        // Getters and setters
    }

    @Entity
    public class Book {
        @Id
        @GeneratedValue
        private Long id;

        private String title;

        @ManyToOne
        private Author author;

        // Getters and setters
    }

  ```

- @ManyToMany

  ```
  @Entity
  public class Student {
      @Id
      @GeneratedValue
      private Long id;

      private String name;

      @ManyToMany
      private List<Course> courses;

      // Getters and setters
  }

  @Entity
  public class Course {
      @Id
      @GeneratedValue
      private Long id;

      private String title;

      @ManyToMany(mappedBy = "courses")
      private List<Student> students;

      // Getters and setters
  }
  ```

7. cascade = CascadeType.ALL:
   When an entity has a relationship with another entity and cascade type is set to CascadeType.ALL, it means that any changes made to the parent entity will be cascaded to the associated child entity. These changes include persisting, updating, removing, and refreshing the child entity.
   orphanRemoval = true:
   The orphanRemoval attribute is used in a one-to-one or one-to-many relationship and works in conjunction with the cascade attribute. If orphanRemoval = true, it means that when a parent entity is removed (orphaned) from the association, the associated child entity will be automatically removed from the database. It ensures that orphaned child entities are deleted when no longer associated with a parent.

8. fetch = FetchType.LAZY:
   When an entity is fetched lazily, it means that the associated entity or collection of entities will not be loaded from the database until the associated data is explicitly accessed or requested. In other words, the related data is fetched on-demand when it's needed.
   fetch = FetchType.EAGER:
   When an entity is fetched eagerly, it means that the associated entity or collection of entities will be immediately loaded from the database along with the parent entity, regardless of whether the associated data is accessed or not.

9.Custom Queries: JPA provides built-in methods for common queries like findById, findAll, etc. However, for more complex queries that cannot be expressed with JPA's query methods, you can create custom query methods using the @Query annotation in Spring Data JPA or using the EntityManager's createQuery method.
Business Logic: You might need to add custom business logic or calculations that involve multiple entities. For example, you may want to calculate a total based on the values of related entities or perform some specific data manipulations before saving an entity.
Validation: You can implement validation logic for entity fields before saving or updating them in the database. This ensures that the data is consistent and meets specific requirements.
Data Processing: In some cases, you may need to process data or perform actions asynchronously, and you can create custom methods to handle such scenarios.
Complex Relationships: For complex relationships between entities that cannot be adequately expressed through annotations alone, you can implement custom methods to handle those relationships.

10. done
11. done
12. done
13. done
14. JPQL stands for Java Persistence Query Language. It is a query language used in Java Persistence API (JPA) to perform database queries on entities, similar to SQL, but designed specifically for querying and manipulating entity objects in an object-oriented manner. JPQL is database-agnostic, allowing developers to write platform-independent queries and work with JPA entities in a standardized way.

15. - `@NamedQuery`
      @NamedQuery is an annotation used in JPA to declare a single named query on an entity class.
      - `@NamedQueries`
        @NamedQueries is an annotation used in JPA to declare multiple named queries on an entity class.

16. @Query is an annotation provided by Spring Data JPA that allows you to define custom queries directly in your Spring Data repository interfaces. With @Query, you can write SQL or JPQL (Java Persistence Query Language) queries within your repository methods.
    You write the SQL or JPQL queries within the Spring Data repository interface, which typically extends one of the Spring Data JPA interfaces like JpaRepository or CrudRepository.

17. HQL (Hibernate Query Language) and Criteria Queries are two different approaches provided by Hibernate, a popular Java ORM (Object-Relational Mapping) framework, for performing database queries and operations.

18. EntityManager is a core interface in the Java Persistence API (JPA) that provides the primary functionality for interacting with the underlying database in a JPA-based application. It serves as the central point for managing entity objects and their persistent state.

19. SessionFactory:
    SessionFactory is a crucial interface in Hibernate responsible for creating and managing Session objects.
    In Hibernate, SessionFactory is a thread-safe and heavyweight object, and typically, an application needs only one instance of SessionFactory.
    Session:
    Session is an interface in Hibernate that represents a single database session, similar to a JDBC Connection.
    Through SessionFactory, you can obtain Session objects, and each Session is associated with a database connection.
20. A transaction is a logical unit of work that consists of one or more database operations. It is a sequence of one or more database operations that must be executed atomically, meaning they must either all succeed or all fail. Transactions ensure data consistency and integrity in a database.

21. Hibernate Caching is a mechanism used by the Hibernate framework to improve the performance of database operations by reducing the number of database queries and round-trips. It involves storing frequently accessed data in memory, allowing subsequent requests to access the data quickly without hitting the database again. This can significantly improve the response time and overall performance of an application.

22.First-level cache (Session-level cache):
First-level cache operates within the scope of a single Hibernate Session.
It is enabled by default and stores the objects that have been retrieved or updated within the current session.
When you query or load an object using Hibernate, it first checks the first-level cache. If the object is already present in the cache, Hibernate returns the cached object directly, avoiding a database query.
The first-level cache is transactional, meaning that it is cleared when the session is flushed or closed, ensuring data consistency within a session.
Second-level cache:
The second-level cache is a shared cache that operates across multiple Hibernate sessions.
It can cache data for multiple users or sessions, providing a shared pool of cached data.
The second-level cache is optional and can be configured for entities and queries, using various cache providers like Ehcache, Infinispan, etc.
By using the second-level cache, data that is repeatedly accessed can be cached and reused across sessions, reducing database load and improving application performance.

23. When a method is annotated with @Transactional, the entire method execution is treated as a database transaction. If any step in the method encounters an exception, the whole transaction will be rolled back, undoing all previous database operations and restoring the database to its state before the transaction began. This mechanism ensures data consistency and integrity in case of failures during complex business logic operations.

24. simple factory design pattern

```
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

class AnimalFactory:
    def create_animal(self, animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        else:
            raise ValueError("Invalid animal type")

# Client code
animal_factory = AnimalFactory()
dog = animal_factory.create_animal("dog")
cat = animal_factory.create_animal("cat")

print(dog.speak())  # Output: "Woof!"
print(cat.speak())  # Output: "Meow!"

```
