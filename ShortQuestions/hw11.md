# HW11
### Name: Yuanzhen Lin

1. List all of the annotations you learned from class and homework to annotaitons.md\
In annotations.md file

2. what is the @configuration and @bean?

The @Configuration and @Bean annotations are part of the Spring Framework for Java, a powerful and flexible framework used for building Java applications.

- @Configuration: \
This annotation is used at the class level and indicates that the class can be used by the Spring IoC container as a source of bean definitions. The @Configuration annotation is a type of stereotype annotation that signals how the class should be processed. A class annotated with @Configuration is a configuration by itself and will have methods to instantiate and configure the dependencies.

- @Bean: \
This annotation is used at the method level and indicates that a method produces a bean to be managed by the Spring container. It's an alternative to defining beans in an XML file. The name of the method serves as the bean's name, and the return values are the types of the objects. When Spring finds an @Bean annotation, it executes that method and registers the return value as a bean within the ApplicationContext.

```aidl
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
```

In this example, the AppConfig class is marked as a configuration class with the @Configuration annotation. Inside it, the myBean() method is annotated with @Bean, meaning Spring will call this method and register the returned object as a bean in the application context. This bean can then be auto-wired/injected wherever it's needed in your application.


3. How do you handle the exception in Spring?

Exception handling in Spring can be performed using several different techniques:
- @ExceptionHandler: \
This is an annotation that can be applied to methods within a Controller in order to specify which exceptions they handle. When a specified exception is thrown within a Controller, the @ExceptionHandler-annotated method will be invoked.

Here is an example:
```aidl
@Controller
public class MyController {
    @RequestMapping("/some-url")
    public String handleRequest() {
        // ...
        return "view-name";
    }

    @ExceptionHandler(Exception.class)
    public String handleException(Exception ex, HttpServletRequest request) {
        // Log the exception, show error page etc.
        return "error-view-name";
    }
}
```
In this example, if any method within the MyController class throws an Exception, the handleException method will be called.

- @ControllerAdvice: \
This is an annotation that can be used to define @ExceptionHandler, @InitBinder, and @ModelAttribute methods that apply to all @RequestMapping methods. So if you want to have a global exception handler that can catch exceptions from all controllers, use @ControllerAdvice.
```aidl
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    public String handleException(Exception ex) {
        // Log the exception, show error page etc.
        return "error-view-name";
    }
}
```
In this example, the handleException method in the GlobalExceptionHandler class will be called whenever an Exception is thrown from any controller method in the application.

- @ResponseStatus: \
This is an annotation that can be used in conjunction with @ExceptionHandler to indicate the HTTP status that should be returned along with the error page when a specific exception is thrown.

- ResponseEntityExceptionHandler: \
This is a convenient base class for @ControllerAdvice classes that wish to provide centralized exception handling across all @RequestMapping methods through @ExceptionHandler methods.

- Custom Error Pages: \
You can also configure custom error pages in your Spring Boot application, either by using server.error.whitelabel.enabled=false in application.properties and creating an 'error' folder under the 'static' or 'templates' folder in the classpath, or by using the ErrorController interface to define a class to control what happens when an error occurs.



4. How do you do the validations in Spring? And list some validation annotaitons you know.

Spring provides support for declarative data validation that can be used to ensure that the data contained in objects meets certain criteria. This is commonly used to validate the data received in HTTP requests (for example, POST or PUT requests) before it's processed.

One of the most common ways of performing validation in Spring is by using the Bean Validation API (JSR 380), which is a Java standard for object validation. In Spring, it's typically used in conjunction with Hibernate Validator, which is the reference implementation for the Bean Validation API.

```aidl
import javax.validation.constraints.*;

public class User {
    @NotEmpty(message = "Name may not be empty")
    private String name;

    @Email(message = "Email should be valid")
    private String email;

    // getters and setters...
}
```

In this example, the @NotEmpty and @Email annotations are used to specify validation rules for the name and email fields respectively. If these rules are not met when an instance of the User class is validated, a ConstraintViolationException will be thrown.

In a Spring MVC controller, you can use the @Valid or @Validated annotation in conjunction with a BindingResult to check for validation errors in a request handler method:
```aidl
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

@RestController
public class UserController {

    @PostMapping("/users")
    public String createUser(@Valid @RequestBody User user, BindingResult result) {
        if (result.hasErrors()) {
            return "error";
        }
        // process the user...
        return "success";
    }
}
```

```aidl
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

@RestController
public class UserController {

    @PostMapping("/users")
    public String createUser(@Valid @RequestBody User user, BindingResult result) {
        if (result.hasErrors()) {
            return "error";
        }
        // process the user...
        return "success";
    }
}
```

In this example, when a POST request is made to "/users", the JSON in the request body is bound to a new User object and validated. If any validation errors occur, they are added to the BindingResult, which can be checked to see if any errors occurred.

Some common validation annotations are:

- @NotNull: The annotated element must not be null.
- @NotEmpty: The annotated element must not be null or empty. Used for collections, arrays, and Strings.
- @NotBlank: The annotated element must not be null or blank. More strict than @NotEmpty, it also checks for whitespace.
- @Positive and @PositiveOrZero: Check that the annotated value is a positive number or zero.
- @Negative and @NegativeOrZero: Check that the annotated value is a negative number or zero.
- @Size(min=, max=): The annotated element's size must be between the specified boundaries. Used for strings, collections, arrays, etc.
- @Email: The annotated string must be a well-formed email address.
- @Pattern(regexp=): The annotated string must match the regular expression.
- @Min(value=): The annotated element must be a number whose value must be higher or equal to the specified minimum.
- @Max(value=): The annotated element must be a number whose value must be lower or equal to the specified maximum.
- @Digits(integer=, fraction=): Checks whether the annotated value is a number having up to 'integer' digits and 'fraction' fractional digits.
- @Past and @PastOrPresent: The annotated date must be in the past or the present.
- @Future and @FutureOrPresent: The annotated date must be in the future or the present.

And many more. You can also define your own custom validation annotations if you have more complex validation needs.


5. What is the actuator?

Actuator is a sub-project that provides production-ready features to help you monitor and manage your application. Actuator exposes operational information about the running application – health, metrics, info, dump, env, etc. It uses HTTP endpoints or JMX beans to interact with it.


In the context of Spring Boot, Actuator is a sub-project that provides production-ready features to help you monitor and manage your application. Actuator exposes operational information about the running application – health, metrics, info, dump, env, etc. It uses HTTP endpoints or JMX beans to interact with it.

Some of the core features of Actuator include:

- Health check: Shows application health information. It's usually used to check database connections, disk space, and other external system statuses your application might depend on.

- Metrics: Provides key application metrics like memory usage, garbage collection, web request statistics, and more.

- Auditing: Tracks user activity within your application.

- HTTP Tracing: Traces HTTP request-response exchanges via the /trace endpoint (for older versions of Spring Boot, prior to 2.2.0) or via the /httptrace endpoint (for Spring Boot 2.2.0 and later).

- Process Monitoring: Provides details about the running application, its environment, and system properties.

- Integrated with External Monitoring systems: Spring Boot Actuator is integrated with external application monitoring systems like Prometheus, Graphite, DataDog, Influx, etc.

6. watch those videos(泛泛地看一遍，能理解多少是多少。没有必要看其它视频)
看完了





