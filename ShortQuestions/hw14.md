## HW13
### Name: Yuanzhen Lin

2. What is the authentication?

Authentication is a process that confirms a user's identity. It's commonly used to ensure that the person trying to access a particular system or service is indeed who they claim to be. This is crucial for the security of any system as it prevents unauthorized access.

3. What is the authorization?

Authorization is a security process that comes after authentication. While authentication is about verifying the identity of a user, authorization is about verifying what that user has permissions to do.

In more technical terms, authorization is the process of granting or denying access to specific resources or abilities once a user's identity has been authenticated.


4. What is the difference between authentication and authorization?

Authentication and authorization are two critical concepts in the world of information security, but they serve different purposes and involve different processes.

Authentication: This is the process of verifying a user's identity. Essentially, it's about ensuring that the person who is trying to access a system or service is indeed who they claim to be. Authentication methods include passwords, PINs, biometrics, or security tokens.

Authorization: Once a user's identity has been authenticated, the next step is to determine what this user is allowed to do within the system. This is where authorization comes in. It's the process of granting or denying access to specific resources or abilities within a system.

To put it in simple terms, authentication is about answering the question, "Are you who you say you are?", while authorization answers the question, "What are you allowed to do?"

So, while they are related and often used together in the process of securing access to systems and data, they are distinct processes addressing different aspects of security. Authentication happens first to establish identity, and then authorization uses that confirmed identity to provide the appropriate level of access.


5. What is HTTP Session?

An HTTP session is a sequence of network request-response transactions. HTTP, which stands for Hypertext Transfer Protocol, is a stateless protocol used for communication on the World Wide Web. Being stateless means that each request is processed independently, without any knowledge of the requests that came before it.

However, in a web application, it's often necessary to maintain state (i.e., remember information) from one request to another, to create a coherent experience for the user. This is where the concept of an "HTTP session" comes into play.

An HTTP session allows a server to store information about a user's interactions that can be accessed across multiple requests. When a user visits a website, the server can create a unique session for that user. For the duration of this session, the server can store user-specific data like authentication status, user preferences, items in a shopping cart, etc. This information can then be accessed and updated over multiple requests.

Session information is usually stored on the server, while the client (i.e., the user's browser) holds a session identifier, often in the form of a cookie. This identifier is sent along with each request to the server, which uses it to look up the corresponding session data.

These sessions can be configured to expire after a certain time of inactivity, which is why you might find yourself logged out of a website after a certain amount of time not doing anything on the site. It's important to manage sessions properly in order to maintain the security and performance of the web application.

6. What is Cookie?

A cookie, also known as an HTTP cookie or web cookie, is a small piece of data stored on the user's computer by the web browser while browsing a website. Cookies were designed to be a reliable mechanism for websites to remember stateful information (such as items added in the shopping cart in an online store) or to record the user's browsing activity (including clicking particular buttons, logging in, or recording which pages were visited in the past).

Cookies play a critical role in facilitating several key functionalities:

- Session Management: Cookies can track login information, shopping cart contents, or any other activity that needs to be remembered across different web pages or browsing sessions.

- Personalization: Cookies allow websites to customize the look and feel of a website to a user's preference. For instance, they can remember themes, language settings, or other preferences.

- Tracking: This is perhaps the most controversial use of cookies. They can be used to observe user behavior over time and across different websites, often for targeted advertising purposes.

It's important to note that while cookies are very useful, they can also be a cause for concern in terms of privacy. Since cookies can track online activity, they can be used to gather quite a bit of information about a user's habits and preferences. Because of these concerns, there are regulations in place in many parts of the world dictating what information can be stored in cookies and how it can be used.


7. What is the difference between Session and Cookie?

Sessions and cookies are both methods used in web applications to store information about a user's interaction with a site, but they work in different ways and have different use cases.

- Session:
  - A session is a way to store information to be used across multiple pages on a server. It is server-side storage of information.
  - Session data is cleared after the session is over (i.e., the user logs out or the session times out).
  - The session data is relatively more secure because it is stored on the server, which makes it harder for a user or attacker to manipulate.
  - As sessions are stored on the server, they can take up more server resources especially if there are many active users.

- Cookie:
  - A cookie is data stored on the client's browser. It is client-side storage of information.
  - Cookies persist even when the browser is closed. They have an expiry time which is set when the cookie is created.
  - Cookies can be less secure as the data is stored on the user's computer, and hence can be accessed and manipulated. For this reason, sensitive data should not be stored in cookies.
  - Cookies have a size limit. Each browser has a limit for the maximum size of each cookie and the total amount of storage used by cookies.

8. How do we use session and cookie to keep user information across the the application?

Web applications commonly use sessions and cookies to maintain state and track user information throughout the application. Here's a simplified description of how this often works:

- User Login: When a user logs into a web application, their login credentials are checked against the data in a database. If the credentials are correct, a new session is created on the server.

- Session Creation: This newly created session is assigned a unique session ID. The server stores and maintains session information such as user details and any other data that needs to persist across requests.

- Creating a Cookie: The unique session ID is then sent to the user's browser and stored there as a cookie. This is often done using a Set-Cookie HTTP header in the server's response.

- Making Requests: Now, whenever the user's browser makes subsequent requests to the server, it includes the session ID cookie in the Cookie HTTP header of the request.

- Session Lookup: The server reads the session ID from the cookie and looks up the session information associated with that ID. This way, the server can 'remember' who the user is and what they're doing.

- User Logout or Session Expiry: The session data is kept on the server until the user logs out or the session expires due to inactivity. The cookie storing the session ID on the user's browser may also be set to expire when the user closes their browser or after a certain amount of time.

This process allows a stateless protocol like HTTP to maintain state across multiple requests, providing a more interactive and seamless user experience. This system also enables the application to secure user data by keeping sensitive information on the server and only a session ID on the client side.

9. What is JWT?

JWT stands for JSON Web Token. It's a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is digitally signed or encrypted.

JWTs can be used to authenticate requests. Once a user has logged in, a JWT can be generated for them and then included in subsequent requests from the client to the server. The server can verify the JWT to confirm the user's identity and provide them with the requested resources.

A JWT consists of three parts, separated by dots (.):

- Header: The header typically consists of two parts: the type of token, which is JWT, and the signing algorithm, such as HMAC SHA256 or RSA.

- Payload: The payload contains the claims, which are statements about an entity (typically, the user) and additional data.

- Signature: The signature is used to verify the sender of the JWT and to ensure that the message wasn't changed along the way.

So, a JWT typically looks like the following: xxxxx.yyyyy.zzzzz

The benefit of using JWTs is that they enable backends to be stateless, which can simplify scaling among other things. The server does not need to keep a record of tokens as each can be independently verified and trusted via digital signature. They also provide a standardized way to generate tokens that can be understood and processed by many different systems, which is useful in a microservices context.

However, they also have their drawbacks. JWTs can be stolen and used to impersonate users, so they should be used over secure HTTPS connections and not contain sensitive information in their payload. They also aren't suitable for every use case and can be overused; for example, using a database can be more appropriate if a token needs to be invalidated before it naturally expires.


10. What is the spring security filter?

Spring Security is a powerful and highly customizable authentication and access control framework for Java applications, particularly for Spring-based applications. 

It is a standard element of Spring-based applications, providing functionalities for authentication and authorization to secure Spring-based applications.

A key component of Spring Security is its series of filters, which are arranged in a chain (known as the Spring Security filter chain) to intercept HTTP requests and responses and implement security controls. Each filter in the chain has a specific job and is able to decide whether to let the request pass, stop it, or redirect it.

Here are some of the key filters used in Spring Security:

- SecurityContextPersistenceFilter: This filter is responsible for storing and restoring the SecurityContext between requests.

- UsernamePasswordAuthenticationFilter: This filter processes form submission for username/password authentication.

- LogoutFilter: This filter allows for programmatic logouts by invalidating the HTTP session, cleaning up any Authentication that is stored in the SecurityContext, and redirecting to a logout success URL.

- ExceptionTranslationFilter: This filter handles any AccessDeniedException and AuthenticationException thrown within the filter chain.

- FilterSecurityInterceptor: This filter performs the authorization (access-control) check before allowing the request to be handled by the application.

Each filter in the chain can be configured, and additional filters can be added, enabling developers to tailor the security to their specific application's needs. Developers can also create custom filters if they need behavior that isn't provided out of the box by Spring Security.


11. describe how do JWT work

JSON Web Tokens (JWT) are used for secure transmission of information between two parties in a compact and self-contained way. This information can be verified and trusted because it is digitally signed using a secret or public/private key pair.

Here's a simplified version of how JWT works:

- User Login: When a user attempts to log in, they send their credentials (like a username and password) to the server

- Generate JWT: 

  - If the credentials are valid, the server generates a JWT, which includes a set of "claims" about the user and other necessary information. The JWT is composed of a header, payload, and signature.

  - The header typically contains the type of the token and the algorithm used for the signature.

  - The payload contains the claims. Claims are statements about an entity (typically, the user) and additional data.

  - The signature is computed using the encoded header, the encoded payload, a secret, and the algorithm specified in the header. The purpose of the signature is to verify that the sender of the JWT is who they say they are and to ensure that the message wasn't changed in transit.

- Send JWT: The server sends the generated JWT back to the client.

- Store JWT: The client stores the JWT usually in memory, local storage, or cookies.

- Send JWT in Future Requests: For future requests, the client includes the JWT in the authorization header of the HTTP request. The format typically looks like: Authorization: Bearer <token>.

- Validate JWT: When the server receives a request with a JWT, it can validate the signature with the secret or the public key, depending on the signing algorithm used. If the signature is valid, the server trusts the information contained in the JWT and processes the request accordingly.

- Renew or Logout: When the token expires, the server will refuse to process the requests with the expired token. The client will need to re-authenticate to get a new token. Alternatively, when the user logs out, the client discards the token, requiring a new login (and therefore a new JWT) for further authenticated requests.

JWTs allow the server to offload the task of maintaining session state to the client, thus reducing the load on the server and making the system more scalable. However, it also comes with security considerations, such as the need to protect the secret used to sign the tokens and the need to use HTTPS to prevent tokens from being intercepted during transmission.


12. Do you use any Encoder to encode Password?

Yes, password encoding (more specifically, password hashing) is a crucial part of secure authentication. In systems where user passwords need to be stored, it's considered best practice to never store the password in plaintext. Instead, passwords are hashed using a one-way hashing algorithm and the hashed value is stored.

In Spring Security, password encoding is handled by the PasswordEncoder interface. This interface defines methods for encoding passwords and comparing a plain text password with an encoded password.

Spring Security provides several implementations of PasswordEncoder, each using a different encoding algorithm:

- BCryptPasswordEncoder: This implementation uses the BCrypt strong hashing function. When a password is encoded, it is randomly salted and followed by the log rounds into the hash. The log rounds determine how much time is needed to encode the password.

- Pbkdf2PasswordEncoder: This implementation uses PBKDF2 (Password-Based Key Derivation Function 2), which is a standard algorithm recommended by NIST for password encoding.

- SCryptPasswordEncoder: This implementation uses the SCrypt hashing function. SCrypt is a password-based key derivation function that is designed to be costly in both time and memory, which would inhibit a brute force attack.

- Argon2PasswordEncoder: Argon2 is a password-hashing function that was selected as the winner of the Password Hashing Competition in July 2015. It's designed to be secure against a wide range of attacks, and is also relatively efficient.


13. What is UserDetailService? AuthenticationProvider?AuthenticationManager? AuthenticationFilter?(把这几个名字看熟悉也行)

- UserDetailsService: 
It is an interface that Spring Security uses to retrieve user-related data. It has a single loadUserByUsername method which locates the user based on the username. This method returns a UserDetails object that Spring Security uses to check the entered user credentials (like username and password) and other user details (like enabled status or authority information). You can provide your custom implementation of this interface to define how user details are retrieved, for example from a database or an external system.

- AuthenticationProvider: 
This is an interface for components that can authenticate a request. It has a method authenticate that takes an Authentication object and returns a fully populated Authentication object if it can authenticate the request. It also has a supports method to indicate which Authentication objects it can handle. There are several built-in implementations like DaoAuthenticationProvider and RememberMeAuthenticationProvider, and you can also create custom ones.

- AuthenticationManager: 
This is an interface that's responsible for passing requests through a chain of AuthenticationProvider instances. An AuthenticationManager has one method, authenticate, which is the same as in the AuthenticationProvider interface. The most commonly used AuthenticationManager implementation is ProviderManager, which delegates to a chain of AuthenticationProvider instances.

- AuthenticationFilter: While not a specific class or interface in Spring Security, this term generally refers to any filter in the Spring Security filter chain that handles authentication. These filters intercept incoming requests and carry out the authentication process. Examples include UsernamePasswordAuthenticationFilter (for form login), BasicAuthenticationFilter (for HTTP Basic auth), JwtAuthenticationFilter (often a custom filter for JWT-based auth), and others.

Each of these components plays a specific role in the authentication process, and Spring Security is designed to let you customize or replace them to suit the needs of your application.

14. What is the disadvantage of Session? how to overcome the disadvantage?

HTTP Sessions are a useful mechanism for preserving state across multiple HTTP requests from a client. However, they do have several potential disadvantages:

- Scalability: If you have a high number of users, storing a lot of data in the session can consume considerable server memory, potentially affecting server performance. This is because HTTP sessions are typically stored in server memory.

- Load Balancing: In a distributed server environment where you have multiple instances of your application running, it can become complex to ensure a user's session data is available to all instances. This is often referred to as session replication or sticky sessions, and it can add complexity to your application's architecture.

- Data Consistency: If you're storing mutable data in the session, it can be tricky to keep this data consistent across multiple servers or requests.

- Long-Lived Sessions: Sessions can be vulnerable to attacks, like session hijacking or session fixation, especially when they're long-lived.


To overcome these disadvantages:

- Use Session Sparingly: Try to limit the amount of data you store in a session. Ideally, only store data that's needed to identify a user or to temporarily store user context data.

- Session Replication/Clustering: In a distributed server environment, you can replicate session data across all instances of your application. However, this adds to the complexity and can affect performance.

- Centralized Session Store: Alternatively, you can store session data in a centralized data store, such as a database or a key-value store like Redis. This ensures that session data is available to all instances of your application.

- Token-Based Authentication: You can use stateless, token-based authentication mechanisms like JWT (JSON Web Tokens) to avoid server-side sessions. The token encapsulates all user information and is sent back and forth in each HTTP request-response. The server doesn't need to store the session data, which makes the application stateless and easily scalable.

- Session Management Practices: Implement good session management practices, such as session timeouts, automatic session expiration, secure transmission of session cookies, and regeneration of session ID after login.

- Use Spring Session: In Spring-based applications, Spring Session can provide a lot of this functionality out of the box. It centralizes session management and allows session information to be shared across different instances, making your application more scalable and robust.

15. how to get value from application.properties?

To access properties defined in application.properties in a Spring Boot application, you can use the @Value annotation or type-safe Configuration Properties.

- Using the @Value Annotation

You can use the @Value annotation to inject property values into fields in Spring-managed beans:
```aidl
@Value("${property.name}")
private String propertyName;
```

Here, property.name is the name of the property you have defined in your application.properties file. The value of the property is injected into the propertyName field when the bean is initialized.


- Using Configuration Properties

A type-safe way to configure properties is to bind them to POJOs. First, you need to create a bean class with fields that correspond to the properties you want to set:
```aidl
@ConfigurationProperties(prefix = "property")
public class MyProperties {
    private String name;
    // getter and setter methods
}
```

Then, you can annotate a @Configuration or a @SpringBootApplication class with @EnableConfigurationProperties and pass your properties class as an argument to that annotation:
```aidl
@SpringBootApplication
@EnableConfigurationProperties(MyProperties.class)
public class MyApplication {
    // ...
}
```

Now, you can inject MyProperties anywhere in your application and use its getter methods to access your properties:
```aidl
@Autowired
private MyProperties myProperties;
```

In the application.properties file, you can define the properties like this:
```aidl
property.name=SomeValue
```

In both of these cases, Spring Boot's automatic property expansion will replace ${property.name} with the value of the property.name property from application.properties.

Remember to have a setter method for each field in the @ConfigurationProperties class, otherwise, Spring won't be able to bind the properties to the fields.


16. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?

These two configure methods in Spring Security play different but integral roles in establishing the security configurations for your application.

- configure(HttpSecurity http): 

This method is where you configure the details of your security policy. It defines which URL paths should be secured and which should not, who can access which parts of your application, what roles they need, what happens when someone tries to access a protected area without proper authorization, and more. For example, you might configure form-based login, HTTP Basic authentication, or which URL patterns are secured.

- configure(AuthenticationManagerBuilder auth): 

This method is used for setting up user details - how users are retrieved and how their credentials (passwords) are checked. You might connect to an LDAP server, query a database, read from an in-memory user store, etc. This is also where you specify the password encoder.

Here's an example:
```aidl
@Autowired
public void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .inMemoryAuthentication()
        .passwordEncoder(new BCryptPasswordEncoder())
            .withUser("user")
            .password(new BCryptPasswordEncoder().encode("password"))
            .roles("USER");
}
```

This example configures an in-memory user store with a single user. The user has the username "user", the password "password" (which is BCrypt-encoded), and a role of "USER".

In summary, configure(HttpSecurity http) is about authorization (who has access to what), while configure(AuthenticationManagerBuilder auth) is about authentication (who the user is).



17. What is Spring security authentication and authorization?

Spring Security is a powerful and highly customizable authentication and access-control (authorization) framework for Java applications, particularly for projects built using the Spring Framework. It's the de-facto standard for securing Spring-based applications.

Authentication and Authorization are two core functions of Spring Security:

- Authentication 

is the process of establishing a known identity for the user, that is, the principal is the entity being authenticated. In simpler terms, it answers the question, "Who is the user?"

In the context of a web application, during the authentication process, users typically provide credentials such as username and password. Spring Security's AuthenticationManager then verifies these credentials and constructs an Authentication object which holds the principal (i.e., typically a user), the credentials (e.g., password), and the authorities granted to the principal.

- Authorization 

is the process of deciding whether a principal is allowed to perform an action within your application. In other words, it answers the question, "Does the authenticated user have access to this resource or perform this action?"

Once authentication is performed, Spring Security uses the GrantedAuthority attached to the Principal to verify whether they have the right to access certain resources or URLs. The @PreAuthorize, @PostAuthorize, @Secured and @RolesAllowed annotations, as well as the hasRole, hasAnyRole, hasAuthority, and hasAnyAuthority methods for URL-based security, are commonly used for authorization.

Spring Security has a comprehensive architecture and it provides support for a wide range of authentication and authorization methods such as LDAP, OAuth, SAML, and others. It's highly customizable, allowing you to tailor its components to your needs.


18. 19\
Done
