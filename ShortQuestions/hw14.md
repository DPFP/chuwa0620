1. See Annotation.md

2. Selenium is *an open-source tool that automates web browsers*. It provides a single interface that lets you write test scripts in programming languages 

3. Cucumber reads executable specifications written in plain text and validates that the software does what those specifications say. The specifications consists of multiple *examples*, or *scenarios*. 

4. Apache JMeter may be used to test performance both on static and dynamic resources, Web dynamic applications.
   It can be used to simulate a heavy load on a server, group of servers, network or object to test its strength or to analyze overall performance under different load types.

5. 

   1. **Setup**: This phase puts the the test infrastructure in place. JUnit provides *class level setup* (*[@BeforeAll](https://howtodoinjava.com/junit5/before-all-annotation-example/)*) and *method level setup* (*[@BeforeEach](https://howtodoinjava.com/junit5/before-each-annotation-example/)*). Generally, heavy objects like databse comnections are created in class level setup while lightweight objects like test objects are reset in the method level setup.
   2. **Test Execution**: In this phase, the *test execution and assertion* happen. The execution result will signify a success or failure.
   3. **Cleanup**: This phase is used to cleanup the test infrastructure setup in the first phase. Just like setup, teardown also happen at *class level ([@AfterAll](https://howtodoinjava.com/junit5/after-all-annotation-example/))* and *method level ([@AfterEach](https://howtodoinjava.com/junit5/after-each-annotation-example/))*.

6. Yes, because heavy objects like database connections needs tobe created in class.

7. Mockito is unit testing framework that has bee integrated in Spring framework.Some drawbacks of Mockito are: **It can not mock static methods**. Classes, constructors and private methods can not be mocked. PowerMockito will be a great tool to solve this problem.

8. The @Mock annotation is used to create mock objects that can be used to replace dependencies in a test class. The @InjectMocks annotation is used to create an instance of a class and inject the mock objects into it, allowing you to test the behavior of the class. I hope this helps!

9. A stub acts as **a small piece of code that replaces another component during testing**. One of the key benefits of using stubs is their ability to consistently return results, which simplifies test writing. Even if the other components are not fully functional yet, you can still execute tests using stubs.

10. ArgumentMatchers **allow us flexible verification or stubbing**. If a method has more than one argument, we can't just use ArgumentMatchers for only some of the arguments. Mockito requires that we provide all arguments either by matchers or exact values

11. Hamcrest is **a framework that assists writing software tests in the Java programming language**. It supports creating customized assertion matchers ('Hamcrest' is an anagram of 'matchers'), allowing match rules to be defined declaratively. These matchers have uses in unit testing frameworks such as JUnit and jMock.

12. **Mocks are used to create fully mock or dummy objects.** **It is mainly used in large test suites.** **Spies are used for creating partial or half mock objects**. 

13. An assertion is **a statement in the Java programming language that enables you to test your assumptions about your program**. 

14. Unit test: Testing the smallest testable units of a program, such as functions or methods. Purpose: Verify the correctness of individual components

    Integration Test: Testing the interactions between multiple components or modules.

    Purpose: Verify that the collaboration between components or modules is correct.

    Regression Test: After modifying the program or environment, re-run previously run tests to confirm that no new errors have been introduced.

    Purpose: Ensure that after changes, existing functionality is still correct.