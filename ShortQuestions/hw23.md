# HW23

## Q5. Write the Singleton design pattern including eager load and lazy load.
  1. Eager load
     ```
     public class EagerSingleton {
          private static final EagerSingleton instance = new EagerSingleton();  //create the instance during instantiation
          
          private EagerSingleton() {}
          
          public static EagerSingleton getInstance() {
              return instance;
          }
      }
     ```
  2. Lazy load
     ```
     public class LazySingleton {
      
          private static LazySingleton instance;
          
          private LazySingleton() {}
          
          public static LazySingleton getInstance() {
              if (instance == null) {
                  instance = new LazySingleton();
              }
              return instance;
          }
      }
    ```

## Q6. What is Runtime Exception? Could you give me some examples?
Runtime exceptions can occur during the execution of a program. <br>
Unlike checked exceptions, runtime exceptions do not need to be declared in a method's signature or explicitly caught by the programmer. <br>
They are usually caused by logical errors or exceptional conditions that are not easily recoverable. <br>
Examples: `NullPointerException`, `ArrayIndexOutOfBoundsException`<br>

## Q7. Could you give me one example of NullPointerException?
  ```
    String str = null;
    int length = str.length(); 
  ```

## Q8. What is the Optional class?
  The Optional class is a container class in Java used to represent a value's presence or absence. <br>
  It is designed to handle situations where a method might not return a value or when a value can be null, providing a more expressive and safer alternative to handling null values. <br>

## Q9. What are the advantages of using the Optional class?
  1. **Avoiding NullPointerExceptions + Clearer Intent** <br>
     `Optional` provides a way to explicitly represent the absence of a value without resorting to using null. <br>
     It helps prevent unexpected null pointer exceptions by forcing the developer to handle the absence of a value explicitly.
     It communicates the intent that a value may or may not be present, making the code easier to understand and maintain.
  2. **Encourages Defensive Programming** <br>
     The use of Optional encourages a defensive programming style by requiring explicit handling of potentially absent values. <br>
     It helps developers identify and handle cases where a value might be missing, reducing the risk of bugs.
  3. **Method Chaining and Functional Style** <br>
     Optional provides a rich set of methods for working with the wrapped value, such as mapping, filtering, and applying default values. <br>
     These methods can be chained together.
  4. **Enhanced Readability** <br>
      By using Optional methods like isPresent(), ifPresent(), and orElse(), your code becomes more readable and self-explanatory. <br>
      It eliminates the need for nested null checks and simplifies the flow of your code.
  5. **Support for Stream Operations**<br>
       integrates well with Java streams, allowing you to seamlessly incorporate optional values into stream processing operations. <br>
       It provides methods like flatMap(), which enables the transformation of optional values within a stream pipeline.

## Q10. What is the @FunctionalInterface?
  The @FunctionalInterface annotation is used to indicate that an interface is intended to be a functional interface. <br>
  A functional interface has exactly one abstract method and can be used as the basis for lambda expressions or method references.
  1. **Single Abstract Method (SAM) Interface** <br>
      A functional interface must have only one abstract method. Can have multiple default method.
  2. **Lambda Expressions and Method References**
     Functional interfaces are primarily used with lambda expressions and method references, which provide a concise way to represent behaviors or actions as values.
  3. **Compile-Time Safety**
     The @FunctionalInterface annotation provides compile-time checks to ensure that the interface meets the requirements of a functional interface. <br>
     If an interface is annotated with @FunctionalInterface and does not satisfy the conditions, the compiler will raise an error.
  4. **Functional Interface Examples**
     Some examples of functional interfaces introduced in Java 8 and beyond include Runnable, Comparator, Consumer, Function, and Predicate. <br>
     These interfaces are commonly used with lambda expressions to provide implementation logic.

## Q11. What is lambda?
  A lambda expression, also known as a lambda function, is a concise way to represent a block of code that can be treated as a method's parameter, assigned to a variable, or used in functional programming constructs.
  1. **Anonymous Functions** <br>
    Lambdas are anonymous because they do not require a name like regular methods. <br>
    They are defined inline and can be used directly without being declared in a separate class or interface.
  2. **Conciseness** <br>
    Lambda expressions allow to express functionality with a compact syntax, reducing the need for verbose anonymous inner classes.
  3. **Functional Interfaces** <br>
    Lambda expressions are commonly used in conjunction with functional interfaces, which are interfaces that define a single abstract method. <br>
    Lambda expressions provide a convenient way to implement the abstract method of a functional interface.'

## Q12. What is Method Reference?
  Method references in Java are compact, easy-to-read lambda expressions for methods that already have a name. <br>
  They're part of Java's functional programming features introduced in Java 8. There are 4 kinds of method reference: <br>
  1. **Reference to a Static Method**
  2. **Reference to an instance method of a particular object**
  3. **Reference to an Instance Method of an Arbitrary Object of a Particular Type**
  4. **Reference to a constructor**

## Q13. What are Java 8 new features?   
  1. lambda expression
  2. stream API
  3. method reference
  4. functional interface + allowing default method in interface
  5. Optional class

## Q14. Can lambda use unchanged variables outside of lambda? what are the details?
  Yes, lambda can use unchanged variables outside of lambda. 
  1. local variables: cannot be modified after it is initialized (effectively final).
  2. instance and static variables: can be modified.
  3. parameters: cannot be modified (effectively final).

## Q15. Describe the newly added features in Java 8?
  Same as Q13.

## Q16. Can a functional interface extend/inherit another interface?
  Yes, it can extend another interface. However, it needs to only maintain on abstract method. <br>
  method 1: extends another interface, remain the same abstract method and not introducing any other new abstract methods. <br>
  method 2: extends another interface, make all the interfaces default and create new abstract method. <br>

## Q17. What is the lambda expression in Java and How does a lambda expression relate to a functional interface?
  What is lambda expression? -> refers to Q11. <br>
  How does lambda expression relate to a functional interface? <br>
  When a lambda expression is assigned to a variable of a functional interface type or passed as a parameter where a functional interface is expected, <br>
  the compiler automatically maps the lambda expression to the single abstract method in the interface.

## Q18. In Java 8, what is Method Reference?
  Same as Q12.

## Q19. What does the String::ValueOf expression mean?
  It uses method reference to refer to the static method valueOf() of the String class.

## Q20. What are Intermediate and Terminal operations?
  **Intermediate operations**: transform a stream into another stream, lazily evaluated. traversal of the pipeline source does not begin until the terminal operation of the pipeline is executed.
  **Terminal operations**: Have side effects and eagerly evaluated. After the terminal operation is performed, the stream pipeline is considered consumed, and can no longer be used.

## Q21. What are the most commonly used Intermediate operations?
  1. `filter(Predicate predicate)`: Returns a stream consisting of the elements of the original stream that match the given predicate.
  2. `map(Function mapper)`:  Returns a stream consisting of the results of applying the given function to the elements of the stream.
  3. `sorted()`: Returns a stream consisting of the elements of the original stream in sorted order.
  4. `distinct()`: Returns a stream consisting of the distinct elements of the original stream.

## Q22. What is the difference between findFirst() and findAny()?
Both `findFirst()` and `findAny()` are terminal operations. They both return an `Optional` describing some element of the stream, or an empty `Optional` if the stream is empty. <br>
Difference: <br>
`findFirst()`: returns the first element from the stream. In a parallel stream, it might have a higher cost because it requires synchronization between threads to ensure the first element is indeed the first one processed. <br>
`findAny()`: returns any element from the stream, not necessarily the first one. In a parallel stream, it might be more efficient because it has more freedom to select any element that is ready instead of waiting for the first one to be processed.

## Q23. How are Collections different from Stream?
  1. **Concept**: <br>
    Collections: primarily concerned with the storage of data and providing efficient ways to manipulate that data (adding, removing, updating, searching, and so forth). <br>
    Stream: designed for computational operations on the data, particularly in a functional programming style and using parallel processing.

  2. **Data Handling**: <br>
    Collections: when you want to handle a finite group of elements. After creation, Collections will hold the data in memory. <br>
    Streams: designed for dealing with large datasets, potentially infinite. Data may all fit in memory. <br>
    When using a Stream, you don't necessarily have to store all data in memory, as elements are computed on-demand.

  3. **Reusability**: <br>
    Collections: can be traversed multiple times.
    Streams: designed to be traversed only once. Once you've consumed a Stream, you cannot revisit the elements.

  4. **Parallelism**: <br>
    Collections: primarily designed to be used with single-threaded operations.
    Streams: designed to transparently parallelize computations without the programmer needing to explicitly write multithreaded code.

  5. **Mutability**: <br>
    Collections: directly manipulable. You can add an element to a collection, remove an element, or change an element. <br>
    Streams: do not change the underlying data source. They perform operations on data and return results; they do not modify the source data.




  

    
     
