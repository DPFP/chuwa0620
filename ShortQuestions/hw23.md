### HW3

1. In Java, generics allow you to create classes, interfaces, and methods that can work with different types of objects while providing compile-time type safety. They enable you to define placeholders for types that are determined at the time of object instantiation or method invocation.

   ```
   public class Box<T> {
       private T content;

       public void put(T item) {
           this.content = item;
       }

       public T get() {
           return content;
       }
   }

    Box<String> stringBox = new Box<>();
    stringBox.put("Hello, World!");
    String message = stringBox.get();
    System.out.println(message);
   ```

2. done
3. done
4. done
5. Eager loading Singleton

   ```
    public class EagerSingleton {
        private static final EagerSingleton instance = new EagerSingleton();

        private EagerSingleton() {
            // Private constructor to prevent instantiation from outside the class
        }

        public static EagerSingleton getInstance() {
            return instance;
        }
    }
   ```

   Lazy loading Singleton

   ```
   public class LazySingleton {
       private static LazySingleton instance;

       private LazySingleton() {
           // 私有构造函数，防止从类外部实例化
       }

       public static synchronized LazySingleton getInstance() {
           if (instance == null) {
               instance = new LazySingleton();
           }
           return instance;
       }
   }

   ```

6. A runtime exception, also known as an unchecked exception, is a type of exception in Java that does not require explicit handling or declaration in the method signature. These exceptions are typically caused by programming errors or exceptional conditions that occur during the execution of a program.

   - NullPointerException
   - ArrayIndexOutOfBoundsException
   - ClassCastException

7. ```
   String str = null;
   int length = str.length(); // Throws NullPointerException
   ```

8. The Optional class is a container class introduced in Java 8 that is used to represent the presence or absence of a value. It provides a way to handle situations where a method may or may not return a value, without explicitly using null references.

9. - Null safety: Optional provides a safe alternative to using null references, reducing the risk of null pointer exceptions.
   - Readability and expressiveness: By using Optional, code becomes more readable and self-explanatory, as it clearly indicates the possibility of a missing value.
   - Defensive programming: It forces developers to explicitly handle the absence of a value, encouraging better error handling and reducing bugs.
   - Method chaining: Optional supports convenient method chaining to perform operations on the wrapped value if it exists.

10. `@FunctionalInterface` is an annotation introduced in Java 8 that is used to indicate that an interface is intended to be a functional interface. A functional interface is an interface that has only one abstract method, known as the functional method. The @FunctionalInterface annotation ensures that the interface adheres to the functional programming principles and allows the use of lambda expressions or method references with that interface.

11. Lambda expressions, also known as lambda functions or anonymous functions, are a key feature introduced in Java 8. They allow the implementation of functional interfaces using a concise syntax. Lambda expressions provide a way to write more expressive and compact code by enabling the direct representation of behavior as a method argument or code block.

12. Method reference is a feature introduced in Java 8 that allows you to refer to an existing method by its name instead of providing a lambda expression. It provides a concise syntax for passing a method as a parameter to a functional interface when the method's signature matches the functional interface's abstract method.

13. - Lambda Expression
    - Stream API
    - Default Methods
    - Optional Class
    - Method References
    - Funcional Interfaces

14. In Java, lambda expressions can capture and use variables from the surrounding context, including variables defined outside the lambda expression. However, there are certain rules and considerations regarding the usage of these variables:

    - Final or effectively final variables: Lambda expressions can only capture local variables that are explicitly declared as final or effectively final. An effectively final variable is one whose value does not change after initialization. Prior to Java 8, local variables used in an anonymous inner class needed to be declared as final, but with lambda expressions, the "final" modifier is not required as long as the variable is effectively final.
    - Variable capture: When a lambda expression uses a variable from its surrounding context, it captures (copies) the value of that variable at the time the lambda is created. This captured value is then used within the lambda expression, even if the variable's value changes outside the lambda later on.
    - Limitations on modifying captured variables: Captured variables from the surrounding context are effectively final within the lambda expression. This means you cannot modify the captured variables within the lambda body.

15. same as Q13
16. Yes, a functional interface can extend or inherit another interface. In Java, functional interfaces are regular interfaces with a single abstract method (SAM). Since Java 8, an interface can extend other interfaces and still be considered a functional interface as long as it has only one abstract method.
17. A lambda expression in Java is a concise way to represent an anonymous function or method. It provides a way to write more compact and expressive code by treating functions as first-class citizens. A lambda expression is associated with a functional interface, which is an interface with a single abstract method. The lambda expression provides an implementation of this single abstract method, making it compatible with the functional interface. This enables the lambda expression to be assigned to a variable of the functional interface type and used in place of an object implementing that interface.
18. same as Q12
19. The String::valueOf expression is an example of a method reference in Java. It refers to the valueOf method of the String class. This method is a static method in the String class that converts different types of values into their string representation.
20. In Java Stream API, intermediate and terminal operations are two types of operations that can be performed on a stream.

    - Intermediate Operations:
      - Intermediate operations are operations that transform or filter the elements of a stream.
      - They are lazy operations, which means they do not produce a result immediately. Instead, they return a new stream that encapsulates the operation to be performed.
      - Examples of intermediate operations include filter, map, distinct, sorted, limit, skip, etc.
    - Terminal Operations:
      - Terminal operations are operations that produce a result or a side-effect.
      - They trigger the processing of elements in a stream and produce a final result or perform an action.
      - Once a terminal operation is executed on a stream, the stream is considered consumed and cannot be reused.
      - Examples of terminal operations include forEach, collect, reduce, count, min, max, etc.

21. listed in Q20
22. findFirst():

    - The findFirst() method returns the first element in the stream, which is determined based on the encounter order of the stream.
    - For ordered streams (e.g., streams created from a List), findFirst() will return the first element in the original order of the elements.
    - For parallel streams or unordered streams, findFirst() will still return the first element encountered during the stream processing, but the order is not guaranteed.
    - This method is useful when you need to get the first element of the stream, especially in cases where the order matters.

    findAny():

    - The findAny() method returns any element in the stream, not necessarily the first element encountered during the stream processing.
    - For parallel streams, findAny() can efficiently return any element encountered in parallel processing, making it suitable for parallel processing or when you don't care which element you get.
    - For ordered streams, findAny() will likely return the first element in the encounter order. However, this behavior is not guaranteed, and in practice, it will usually return the first element, but you shouldn't rely on it if you need a consistent result.
    - This method is useful when you want to get any element from the stream without caring about the order.

23. Collections are data structures that store and manage a group of objects in memory, while streams are a sequence of elements that enable functional-style processing and operations on the data. Collections are suitable for direct access and manipulation of elements, while streams are designed for declarative and functional transformations and processing of data.
