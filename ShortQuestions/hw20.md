## HW20

### 1. Write up Example code to demonstrate the three foundmental concepts of OOP. (reference Code Demo repo as example)
see details in Coding/src/main/java/OopExercise.java


### 2. What is wrapper class in Java and Why we need wrapper class?

Wrapper classes in Java are classes that encapsulate primitive data types (such as int, char, boolean, etc.) and provide methods to manipulate and work with them as objects. We need wrapper classes because Java is an object-oriented language, and many APIs and libraries expect objects as parameters or return types. Wrapper classes bridge the gap between primitive types and objects.

### 3. What is the difference between HashMap and HashTable?

HashMap and HashTable are both implementations of the Map interface in Java, but they have some differences:

- Synchronization: HashTable is synchronized, meaning it is thread-safe and can be accessed by multiple threads concurrently. HashMap, on the other hand, is not synchronized and is not thread-safe by default. However, you can make a HashMap synchronized by using `Collections.synchronizedMap()` method.
- Null keys and values: HashTable does not allow null keys or values, whereas HashMap allows one null key and multiple null values.
- Performance: HashMap generally performs better than HashTable in single-threaded scenarios because of the absence of synchronization overhead.

### 4. What is String pool in Java and why we need String pool?

String pool in Java is a pool of strings stored in the heap memory. When a string is created using double quotes ("..."), Java checks if the string already exists in the pool. If it does, the reference to the existing string is returned instead of creating a new object. This saves memory and improves performance when dealing with string literals or frequently used strings.

### 5. What is Java garbage collection?

Java garbage collection is the process of automatically reclaiming memory occupied by objects that are no longer in use. It is performed by the JVM to manage memory and deallocate objects that are no longer reachable by the application. The garbage collector identifies objects that are eligible for garbage collection based on reachability analysis, and then releases the memory occupied by those objects.

### 6. What are access modifiers and their scopes in Java?

Access modifiers in Java control the visibility and accessibility of classes, methods, and fields. There are four access modifiers:

- public: Accessible from anywhere.
- protected: Accessible within the same package and subclasses, even if they are in different packages.
- default (no modifier): Accessible within the same package only.
- private: Accessible within the same class only.

### 7. What is final key word? (Filed, Method, Class)

The final keyword in Java is used to restrict certain behaviors:

- Final fields: Once assigned, the value of a final field cannot be changed.
- Final methods: Final methods cannot be overridden by subclasses.
- Final classes: Final classes cannot be extended or subclassed.

### 8. What is static keyword? (Filed, Method, Class). When do we usually use it?

The static keyword in Java is used to define members (fields or methods) that belong to the class itself, rather than to instances of the class. Here are the uses of static:

- Static fields: Shared among all instances of the class.
- Static methods: Can be called without creating an instance of the class.
- Static class: A nested class that does not require an instance of the outer class to be instantiated.

### 9. What is the differences between overriding and overloading?

Overriding refers to the ability of a subclass to provide a specific implementation of a method that is already defined in its superclass. Overloading, on the other hand, refers to having multiple methods with the same name but different parameters within the same class. Overloading is determined at compile-time based on the method signature, whereas overriding is determined at runtime based on the actual object type.

### 10. What is the differences between super and this?

The super keyword in Java is used to refer to the superclass of a class or to call the superclass's constructor or methods. It is used to differentiate between members of the superclass and the subclass that have the same name. The this keyword, on the other hand, is used to refer to the current instance of the class and can be used to access instance variables or invoke other constructors of the same class.

### 11. What is the Java load sequence?

Java load sequence refers to the order in which classes and their static components (static blocks, static fields, static methods) are loaded and initialized by the JVM. The sequence is generally as follows:

- Superclass static components are loaded and initialized.
- Subclass static components are loaded and initialized.
- Superclass instance variables and instance initialization blocks are executed.
- Superclass constructor is called.
- Subclass instance variables and instance initialization blocks are executed.
- Subclass constructor is called.

### 12. What is Polymorphism ? And how Java implements it ?

Polymorphism in Java refers to the ability of an object to take on different forms or types. It allows a subclass to be treated as an instance of its superclass. Java implements polymorphism through method overriding, where a subclass provides its own implementation of a method defined in its superclass. This allows for more flexibility and extensibility in the code.

### 13. What is Encapsulation ? How Java implements it? And why we need encapsulation?

Encapsulation in Java is the practice of bundling related data and methods together within a class and controlling access to them. It involves declaring the class fields as private and providing public methods (getters and setters) to access or modify the field values. Encapsulation helps in data hiding, ensuring data integrity, and provides a level of abstraction to the users of the class.

### 14. What is Interface and what is abstract class? What are the differences between them?

Interface in Java is a collection of abstract methods (methods without an implementation) that define a contract for a class to implement. It defines the behavior that a class should adhere to. An abstract class is a class that cannot be instantiated and may contain both abstract and non-abstract methods. It serves as a base class for other classes to inherit from. The main difference between an interface and an abstract class is that a class can implement multiple interfaces, but it can inherit from only one abstract class. Interfaces are typically used to define common behavior across unrelated classes, while abstract classes provide a common base for related classes to inherit from.

### 15. (OOD) Design a parking lot (put the code to codingQuestions/coding1 folder, )


### 16. What are Queue interface implementations and what are the differences and when to use what?

The Java Queue interface is implemented by several classes in the Java Collections Framework to provide different queueing behavior. Here are some common implementations of the Queue interface and their differences:

- LinkedList: LinkedList implements the Queue interface and provides a doubly-linked list implementation of the queue. It allows elements to be added or removed from both ends of the list, making it suitable for implementing a FIFO (First-In-First-Out) queue.

- ArrayDeque: ArrayDeque is a resizable array-based implementation of the Deque interface, which extends the Queue interface. It can function as both a queue and a stack, allowing elements to be added or removed from both ends. ArrayDeque provides better performance than LinkedList in most cases.

- PriorityQueue: PriorityQueue is an implementation of the Queue interface that provides a priority-based ordering of elements. Elements are ordered based on their natural ordering or a custom comparator provided during the PriorityQueue's construction. The element with the highest priority is always at the front of the queue.

When to use each implementation depends on your specific requirements:

- Use LinkedList when you need a basic FIFO queue implementation and frequent insertions/deletions at both ends of the queue.
- Use ArrayDeque when you need a general-purpose queue implementation with good performance and flexibility for both queue and stack operations.
- Use PriorityQueue when you need elements to be ordered based on their priority, allowing you to retrieve the highest-priority element efficiently.
