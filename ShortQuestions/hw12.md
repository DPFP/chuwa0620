# HW6
### Name: Yuanzhen Lin

1. List all of the annotations you learned from class and homework to annotaitons.md\
Located at annotations.md


2. What is Spring and Springboot? What is the benfits of using Srpingboot?

Spring is a powerful and flexible framework used for building Java applications. It provides comprehensive infrastructure support for developing Java applications, enabling you to focus on your application-level business logic rather than on the underlying plumbing.

Key features and benefits of Spring include:

- Dependency Injection/Inversion of Control (IoC): This promotes loose coupling in code and makes the application easier to test and maintain.
- Aspect-Oriented Programming (AOP): This allows you to modularize cross-cutting concerns in applications, such as logging and transactions.
- Data access: Provides a JDBC abstraction framework to eliminate boilerplate code. Also supports integration with ORM frameworks like Hibernate.
- Spring MVC: A web application framework that provides a robust environment for developing flexible and loosely coupled web applications.
- Transaction management: Provides a consistent programming model across different transaction APIs such as JTA, JDBC, Hibernate, JPA, and JDO.

Spring Boot, on the other hand, is a project built on top of the Spring Framework. It is a way to ease the creation of stand-alone, production-grade applications that you can just run, typically on a web server. It simplifies Spring dependencies by taking an opinionated view of the platform.

Benefits of using Spring Boot include:

- Auto-configuration: Spring Boot automatically configures your application based on the libraries present on the classpath. This greatly reduces the amount of manual configuration that needs to be done.
- Stand-alone: Spring Boot applications are stand-alone, meaning they include an embedded web server (Tomcat, Jetty, or Undertow) and do not need to be deployed on a separate server.
- Production Ready: Spring Boot includes non-functional features such as metrics, health checks, and externalized configuration out of the box. This makes Spring Boot applications ready for production environments.
- No XML: There is no need for XML configuration files, making the setup and configuration process much easier and faster.
- Dependency management: Spring Boot comes with a set of default dependencies to get started quickly, reducing the time spent on project setup.

In summary, while Spring provides a comprehensive framework for building enterprise Java applications, Spring Boot simplifies the process by removing much of the boilerplate configuration, making it faster and easier to create Spring applications.


3. What is IOC and What is DI?

Inversion of Control (IoC) and Dependency Injection (DI) are design patterns used in programming and software development. They're both related to how components get references to their dependencies. Here's a brief explanation of both:

- Inversion of Control (IoC): 

This is a design principle in which the control flow of a program is inverted compared to traditional procedural programming. In procedural programming, the control flow of the program is dictated by the programmer, and the program calls libraries or APIs as needed. In IoC, however, the control flow is inverted—the program provides the libraries/APIs, and a container or framework calls the program.

IoC can be used to increase modularity, make systems easier to test and maintain, and enable "programming by contract". It's used in a lot of different contexts, not just dependency management. For example, event-driven programming, where you define event handlers and then a GUI framework or event loop calls them, can be seen as a form of IoC.


- Dependency Injection (DI): 

This is a specific form of IoC, where the control being inverted is the control of how a component gets references to its dependencies. In traditional programming, a component that needs to use another component or service is responsible for creating it or finding it. With DI, instead of components finding the services they need, a container or framework gives (injects) the components the services when they're created.

DI can make code more flexible and reusable, because it separates the use of services from their creation or location. It makes code easier to test, because you can inject mock services into components when testing them. And it can make systems easier to modify, because you can change what services get injected without having to change the components that use them.

In the context of the Spring framework, IoC and DI refer to the way Spring manages beans. A bean is an object that is instantiated, assembled, and managed by a Spring IoC container. The container injects dependencies into the beans (DI), manages their lifecycle, configures them, and provides them to other beans as needed. This takes control away from the beans themselves and gives it to the container (IoC), leading to more modular, testable, and maintainable code.

4. What is @CompnonentScan?

The @ComponentScan annotation in Spring is used to automatically discover beans and register them in the Spring application context. It tells Spring where to look for components, configurations and services to include them into the application context.

It tells Spring where to look for components, configurations and services to include them into the application context.

By default, Spring will scan the current package and all its sub-packages. For example:
```aidl
package com.example.myapp;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan
public class AppConfig {
    // ...
}
```

In the example above, Spring will scan all classes in the com.example.myapp package and its sub-packages for @Component, @Controller, @Service, @Repository, and @Configuration annotations, and automatically create beans for those classes.

You can also specify a base package (or packages) for Spring to scan:
```aidl
@Configuration
@ComponentScan(basePackages = "com.example.myapp.services")
public class AppConfig {
    // ...
}
```

In this case, Spring will only scan the com.example.myapp.services package and its sub-packages.

You can also specify multiple base packages like this:
```aidl
@Configuration
@ComponentScan(basePackages = {"com.example.myapp.services", "com.example.myapp.repositories"})
public class AppConfig {
    // ...
}
```


5. How to define which package spring need to scan in xml and annotaiton?

In a Spring application, you can instruct the Spring Framework where to look for Spring beans either using an XML configuration file or using Java annotations.

- Using XML Configuration:

To define which package Spring needs to scan in an XML configuration file, you can use the <context:component-scan> tag. Here is an example:
```aidl
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="com.example.myapp" />

</beans>
```
In this example, Spring will scan the com.example.myapp package for any classes annotated with @Component, @Service, @Repository, @Controller, etc., and automatically create beans for those classes.

- Using Annotations:

If you are using Java annotations, you can use the @ComponentScan annotation to specify which packages Spring should scan. Here is an example:
```
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "com.example.myapp")
public class AppConfig {

}
```

In this example, Spring will again scan the com.example.myapp package for any classes annotated with @Component, @Service, @Repository, @Controller, etc., and automatically create beans for those classes.

For multiple packages, you can specify them like this:
```aidl
@Configuration
@ComponentScan(basePackages = {"com.example.myapp", "com.example.myapp2"})
public class AppConfig {

}
```

6. What is @SpringbootApplication?

@SpringBootApplication is a convenience annotation in Spring Boot that adds all of the following annotations:
- @Configuration: This allows the class to be used as a source of bean definitions.

- @EnableAutoConfiguration: This enables automatic configuration of the Spring application context, attempting to guess and configure beans that you are likely to need based on your classpath and other beans you have defined.

- @ComponentScan: This enables auto-detection of beans from the same package as the class where this annotation is used or from its sub-packages.


When you use @SpringBootApplication, you're essentially using all three of these core annotations with their default attributes.

Here's a basic example of a Spring Boot application that uses @SpringBootApplication:
```aidl
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
```

In the code above, the Application class is marked with @SpringBootApplication, so it's recognized by Spring as a configuration class. The main() method uses Spring Boot’s SpringApplication.run() method to launch the application.


7. How many ways wo can define a bean?

In Spring Framework, you can define a bean in several ways:

- XML-Based Configuration: 

This is the traditional way of defining beans in Spring. In your Spring XML configuration file, you can define a bean using the <bean> tag:
```aidl
<bean id="myBean" class="com.example.MyBeanClass"></bean>
```
Here, the id attribute is the name of the bean, and the class attribute is the fully qualified class name of the bean.

- Annotation-Based Configuration: 

With this configuration, you can define a bean using one of several annotations on your class. These annotations include @Component, @Service, @Repository, and @Controller. Spring's component-scanning mechanism detects these classes and automatically registers them as beans.

```aidl
@Component
public class MyBeanClass {
    // ...
}
```

Here, MyBeanClass would be detected and registered as a bean when component scanning is enabled.

- Java-Based Configuration: 

In this configuration, you define beans using Java configuration classes. These classes contain methods annotated with @Bean. Each @Bean method defines a bean:
```aidl
@Configuration
public class AppConfig {

    @Bean
    public MyBeanClass myBean() {
        return new MyBeanClass();
    }
}
```
In this case, a MyBeanClass bean will be available in the Spring context, and it can be autowired into any other Spring-managed component.

- Automatic Configuration with Spring Boot:

Spring Boot can automatically configure beans based on the libraries present on your classpath, sparing you the need to manually define and configure these beans. For instance, if you have a DataSource on your classpath, Spring Boot can automatically configure a DataSource bean for you.

It's important to note that no matter which method you choose to define your beans, the Spring IoC container will manage them in the same way. The difference lies in how you tell Spring about the beans and their dependencies.



8. What is default bean name for @Component and @Bean?

In Spring Framework, the default bean names are determined based on the following rules:

- @Component:

When you annotate a class with @Component (or @Service, @Repository, @Controller which are special types of @Component), the default bean name is the uncapitalized non-qualified class name.

For example, if you have:
```aidl
@Component
public class MyComponentClass {
}
```
The default bean name would be "myComponentClass".


- @Bean:

For a method annotated with @Bean, the default bean name is the name of the method.

For example, if you have:
```
@Configuration
public class AppConfig {

    @Bean
    public MyBeanClass myBean() {
        return new MyBeanClass();
    }
}
```

The default bean name would be "myBean".

In both cases, you can also explicitly provide a name or names. For @Component, you would provide the name as an argument like @Component("myBeanName"). For @Bean, you can provide the name or names as an argument to the annotation like @Bean(name = "myBeanName") or @Bean(name = {"myBeanName1", "myBeanName2"}).

The bean name is used when you want to reference the bean from other parts of your application, like when you use @Autowired or @Qualifier to inject beans.


9. What is the difference between @component and @service,@repository?

In Spring Framework, @Component, @Service, and @Repository are annotations that are used to indicate that a class is a Spring Bean. Spring's component scanning mechanism will detect these classes and create beans from them. They are all stereotype annotations, but they have slightly different uses and semantics:

- @Component: 

This is a generic annotation for any Spring-managed component. If a class doesn't fit into the categories of @Service, @Repository, or @Controller (for MVC model), then we can use @Component to mark this class as a Spring Bean.

- @Service: 

This annotation is a specialization of @Component. It has the same functionality as @Component, but it's used for classes that provide some business functionalities. Spring @Service beans are typically service facades, business services, or services that contain business logic.


- @Repository: 

This is another specialization of @Component, used for DAOs (Data Access Objects). The DAOs are responsible for providing CRUD operations on objects. The @Repository annotation not only marks the class as a Bean but also brings in additional benefits specifically for DAOs, like translation of database-related exceptions into Spring's DataAccessException hierarchy.

It's important to note that these annotations don't change the behavior of the Spring beans themselves. They are used more for the benefit of the developers, as they provide a way to clearly indicate the role of your component in the application. This can be helpful when you are working with large projects where it's important to keep the architecture and layering clear.

Another advantage of using these more specific annotations is that they can be picked up by aspects, tools, or other pieces of code which you can use to add behavior to all components of a certain type. For instance, you might add a database exception handling aspect that applies only to @Repository beans.



