# HW6
### Name: Yuanzhen Lin

1. List all of the annotations you learned from class and homework to annotaitons.md\
Located at annotations.md


2. What is Spring and Springboot? What is the benfits of using Srpingboot?

Spring is a powerful and flexible framework used for building Java applications. It provides comprehensive infrastructure support for developing Java applications, enabling you to focus on your application-level business logic rather than on the underlying plumbing.

Key features and benefits of Spring include:

- Dependency Injection/Inversion of Control (IoC): This promotes loose coupling in code and makes the application easier to test and maintain.
- Aspect-Oriented Programming (AOP): This allows you to modularize cross-cutting concerns in applications, such as logging and transactions.
- Data access: Provides a JDBC abstraction framework to eliminate boilerplate code. Also supports integration with ORM frameworks like Hibernate.
- Spring MVC: A web application framework that provides a robust environment for developing flexible and loosely coupled web applications.
- Transaction management: Provides a consistent programming model across different transaction APIs such as JTA, JDBC, Hibernate, JPA, and JDO.

Spring Boot, on the other hand, is a project built on top of the Spring Framework. It is a way to ease the creation of stand-alone, production-grade applications that you can just run, typically on a web server. It simplifies Spring dependencies by taking an opinionated view of the platform.

Benefits of using Spring Boot include:

- Auto-configuration: Spring Boot automatically configures your application based on the libraries present on the classpath. This greatly reduces the amount of manual configuration that needs to be done.
- Stand-alone: Spring Boot applications are stand-alone, meaning they include an embedded web server (Tomcat, Jetty, or Undertow) and do not need to be deployed on a separate server.
- Production Ready: Spring Boot includes non-functional features such as metrics, health checks, and externalized configuration out of the box. This makes Spring Boot applications ready for production environments.
- No XML: There is no need for XML configuration files, making the setup and configuration process much easier and faster.
- Dependency management: Spring Boot comes with a set of default dependencies to get started quickly, reducing the time spent on project setup.

In summary, while Spring provides a comprehensive framework for building enterprise Java applications, Spring Boot simplifies the process by removing much of the boilerplate configuration, making it faster and easier to create Spring applications.


3. What is IOC and What is DI?

Inversion of Control (IoC) and Dependency Injection (DI) are design patterns used in programming and software development. They're both related to how components get references to their dependencies. Here's a brief explanation of both:

- Inversion of Control (IoC): 

This is a design principle in which the control flow of a program is inverted compared to traditional procedural programming. In procedural programming, the control flow of the program is dictated by the programmer, and the program calls libraries or APIs as needed. In IoC, however, the control flow is inverted—the program provides the libraries/APIs, and a container or framework calls the program.

IoC can be used to increase modularity, make systems easier to test and maintain, and enable "programming by contract". It's used in a lot of different contexts, not just dependency management. For example, event-driven programming, where you define event handlers and then a GUI framework or event loop calls them, can be seen as a form of IoC.


- Dependency Injection (DI): 

This is a specific form of IoC, where the control being inverted is the control of how a component gets references to its dependencies. In traditional programming, a component that needs to use another component or service is responsible for creating it or finding it. With DI, instead of components finding the services they need, a container or framework gives (injects) the components the services when they're created.

DI can make code more flexible and reusable, because it separates the use of services from their creation or location. It makes code easier to test, because you can inject mock services into components when testing them. And it can make systems easier to modify, because you can change what services get injected without having to change the components that use them.

In the context of the Spring framework, IoC and DI refer to the way Spring manages beans. A bean is an object that is instantiated, assembled, and managed by a Spring IoC container. The container injects dependencies into the beans (DI), manages their lifecycle, configures them, and provides them to other beans as needed. This takes control away from the beans themselves and gives it to the container (IoC), leading to more modular, testable, and maintainable code.

4. What is @CompnonentScan?

The @ComponentScan annotation in Spring is used to automatically discover beans and register them in the Spring application context. It tells Spring where to look for components, configurations and services to include them into the application context.

It tells Spring where to look for components, configurations and services to include them into the application context.

By default, Spring will scan the current package and all its sub-packages. For example:
```aidl
package com.example.myapp;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan
public class AppConfig {
    // ...
}
```

In the example above, Spring will scan all classes in the com.example.myapp package and its sub-packages for @Component, @Controller, @Service, @Repository, and @Configuration annotations, and automatically create beans for those classes.

You can also specify a base package (or packages) for Spring to scan:
```aidl
@Configuration
@ComponentScan(basePackages = "com.example.myapp.services")
public class AppConfig {
    // ...
}
```

In this case, Spring will only scan the com.example.myapp.services package and its sub-packages.

You can also specify multiple base packages like this:
```aidl
@Configuration
@ComponentScan(basePackages = {"com.example.myapp.services", "com.example.myapp.repositories"})
public class AppConfig {
    // ...
}
```


5. How to define which package spring need to scan in xml and annotaiton?

In a Spring application, you can instruct the Spring Framework where to look for Spring beans either using an XML configuration file or using Java annotations.

- Using XML Configuration:

To define which package Spring needs to scan in an XML configuration file, you can use the <context:component-scan> tag. Here is an example:
```aidl
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="com.example.myapp" />

</beans>
```
In this example, Spring will scan the com.example.myapp package for any classes annotated with @Component, @Service, @Repository, @Controller, etc., and automatically create beans for those classes.

- Using Annotations:

If you are using Java annotations, you can use the @ComponentScan annotation to specify which packages Spring should scan. Here is an example:
```
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "com.example.myapp")
public class AppConfig {

}
```

In this example, Spring will again scan the com.example.myapp package for any classes annotated with @Component, @Service, @Repository, @Controller, etc., and automatically create beans for those classes.

For multiple packages, you can specify them like this:
```aidl
@Configuration
@ComponentScan(basePackages = {"com.example.myapp", "com.example.myapp2"})
public class AppConfig {

}
```

6. What is @SpringbootApplication?

@SpringBootApplication is a convenience annotation in Spring Boot that adds all of the following annotations:
- @Configuration: This allows the class to be used as a source of bean definitions.

- @EnableAutoConfiguration: This enables automatic configuration of the Spring application context, attempting to guess and configure beans that you are likely to need based on your classpath and other beans you have defined.

- @ComponentScan: This enables auto-detection of beans from the same package as the class where this annotation is used or from its sub-packages.


When you use @SpringBootApplication, you're essentially using all three of these core annotations with their default attributes.

Here's a basic example of a Spring Boot application that uses @SpringBootApplication:
```aidl
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
```

In the code above, the Application class is marked with @SpringBootApplication, so it's recognized by Spring as a configuration class. The main() method uses Spring Boot’s SpringApplication.run() method to launch the application.


7. How many ways wo can define a bean?

In Spring Framework, you can define a bean in several ways:

- XML-Based Configuration: 

This is the traditional way of defining beans in Spring. In your Spring XML configuration file, you can define a bean using the <bean> tag:
```aidl
<bean id="myBean" class="com.example.MyBeanClass"></bean>
```
Here, the id attribute is the name of the bean, and the class attribute is the fully qualified class name of the bean.

- Annotation-Based Configuration: 

With this configuration, you can define a bean using one of several annotations on your class. These annotations include @Component, @Service, @Repository, and @Controller. Spring's component-scanning mechanism detects these classes and automatically registers them as beans.

```aidl
@Component
public class MyBeanClass {
    // ...
}
```

Here, MyBeanClass would be detected and registered as a bean when component scanning is enabled.

- Java-Based Configuration: 

In this configuration, you define beans using Java configuration classes. These classes contain methods annotated with @Bean. Each @Bean method defines a bean:
```aidl
@Configuration
public class AppConfig {

    @Bean
    public MyBeanClass myBean() {
        return new MyBeanClass();
    }
}
```
In this case, a MyBeanClass bean will be available in the Spring context, and it can be autowired into any other Spring-managed component.

- Automatic Configuration with Spring Boot:

Spring Boot can automatically configure beans based on the libraries present on your classpath, sparing you the need to manually define and configure these beans. For instance, if you have a DataSource on your classpath, Spring Boot can automatically configure a DataSource bean for you.

It's important to note that no matter which method you choose to define your beans, the Spring IoC container will manage them in the same way. The difference lies in how you tell Spring about the beans and their dependencies.



8. What is default bean name for @Component and @Bean?

In Spring Framework, the default bean names are determined based on the following rules:

- @Component:

When you annotate a class with @Component (or @Service, @Repository, @Controller which are special types of @Component), the default bean name is the uncapitalized non-qualified class name.

For example, if you have:
```aidl
@Component
public class MyComponentClass {
}
```
The default bean name would be "myComponentClass".


- @Bean:

For a method annotated with @Bean, the default bean name is the name of the method.

For example, if you have:
```
@Configuration
public class AppConfig {

    @Bean
    public MyBeanClass myBean() {
        return new MyBeanClass();
    }
}
```

The default bean name would be "myBean".

In both cases, you can also explicitly provide a name or names. For @Component, you would provide the name as an argument like @Component("myBeanName"). For @Bean, you can provide the name or names as an argument to the annotation like @Bean(name = "myBeanName") or @Bean(name = {"myBeanName1", "myBeanName2"}).

The bean name is used when you want to reference the bean from other parts of your application, like when you use @Autowired or @Qualifier to inject beans.


9. What is the difference between @component and @service,@repository?

In Spring Framework, @Component, @Service, and @Repository are annotations that are used to indicate that a class is a Spring Bean. Spring's component scanning mechanism will detect these classes and create beans from them. They are all stereotype annotations, but they have slightly different uses and semantics:

- @Component: 

This is a generic annotation for any Spring-managed component. If a class doesn't fit into the categories of @Service, @Repository, or @Controller (for MVC model), then we can use @Component to mark this class as a Spring Bean.

- @Service: 

This annotation is a specialization of @Component. It has the same functionality as @Component, but it's used for classes that provide some business functionalities. Spring @Service beans are typically service facades, business services, or services that contain business logic.


- @Repository: 

This is another specialization of @Component, used for DAOs (Data Access Objects). The DAOs are responsible for providing CRUD operations on objects. The @Repository annotation not only marks the class as a Bean but also brings in additional benefits specifically for DAOs, like translation of database-related exceptions into Spring's DataAccessException hierarchy.

It's important to note that these annotations don't change the behavior of the Spring beans themselves. They are used more for the benefit of the developers, as they provide a way to clearly indicate the role of your component in the application. This can be helpful when you are working with large projects where it's important to keep the architecture and layering clear.

Another advantage of using these more specific annotations is that they can be picked up by aspects, tools, or other pieces of code which you can use to add behavior to all components of a certain type. For instance, you might add a database exception handling aspect that applies only to @Repository beans.


10. How many annotaitons we can use to inject the bean?

In Spring Framework, there are primarily three annotations used to inject beans. These are:

- @Autowired: This annotation is used for automatic dependency injection. It can be used on variables, methods, and constructors. The @Autowired annotation injects the beans by type (i.e., it matches the class or interface that the bean implements).
```
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class MyService {

    @Autowired
    private MyBeanClass myBean;
}
```
- @Inject: This annotation is part of the JSR-330 standard for dependency injection in Java. It works in a similar way to @Autowired, but it's not a Spring-specific annotation. @Inject can be used as an alternative to @Autowired if you want to follow standard annotations rather than ones that are specific to Spring. However, it may lack some of the additional features of @Autowired, such as the 'required' attribute.
```
import javax.inject.Inject;
import org.springframework.stereotype.Component;

@Component
public class MyService {

    @Inject
    private MyBeanClass myBean;
}
```
- @Resource: This annotation is part of the JSR-250 standard, and it injects beans by name rather than type. You can provide the name of the bean that you want to inject using the 'name' attribute.
```aidl
import javax.annotation.Resource;
import org.springframework.stereotype.Component;

@Component
public class MyService {

    @Resource(name="myBean")
    private MyBeanClass myBean;
}
```
In addition to these, you can also use the @Qualifier annotation in conjunction with @Autowired or @Inject to further control which bean gets injected when there are multiple beans of the same type.
```aidl
@Autowired
@Qualifier("beanName")
private MyBeanClass myBean;
```

In this case, the @Qualifier annotation is used to specify the name of the bean that should be autowired into 'myBean'.

Remember, you should avoid field injection where possible and prefer constructor injection as it enables immutability, ensures that required dependencies are not null and simplifies testing. Here's an example using constructor injection:
```aidl
private final MyBeanClass myBean;

@Autowired
public MyClass(MyBeanClass myBean) {
    this.myBean = myBean;
}
```

Starting from Spring 4.3, if a class has only one constructor, you can even omit the @Autowired annotation:
```aidl
private final MyBeanClass myBean;

public MyClass(MyBeanClass myBean) {
    this.myBean = myBean;
}
```

11. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?

In Spring Framework, there are three main ways to perform dependency injection:

- Constructor Injection: 

As the name suggests, this method injects dependencies through the class constructor. Here's an example:
```aidl
@Component
public class MyClass {

    private final MyDependency myDependency;

    @Autowired
    public MyClass(MyDependency myDependency) {
        this.myDependency = myDependency;
    }
}
```

- Setter Injection: 

This method involves providing a public setter method in the class where a dependency can be injected. Here's an example:
```aidl
@Component
public class MyClass {

    private MyDependency myDependency;

    @Autowired
    public void setMyDependency(MyDependency myDependency) {
        this.myDependency = myDependency;
    }
}
```

- Field Injection: 

- In this method, you annotate the fields you want to inject with @Autowired. Spring will automatically inject the dependencies directly into the fields, even if they are private. Here's an example:
```aidl
@Component
public class MyClass {

    @Autowired
    private MyDependency myDependency;
}
```

Among these methods, Constructor Injection is generally recommended and considered the best practice. There are several reasons for this:
- Immutable Fields: With constructor injection, you can make your injected fields final. This ensures that once the dependencies are set, they cannot be changed.

- Clear Dependencies: By looking at the constructor of a class, you can immediately see what dependencies it requires. This is not the case with field or setter injection, where you have to inspect the entire class.

- Avoiding Nulls: With constructor injection, the container ensures that all the dependencies are resolved at the time of bean creation itself. This avoids NullPointerException that may occur in case of setter or field injection.

- Facilitates Unit Testing: Constructor injection makes it easier to write unit tests because you can easily instantiate your object with specific dependencies in your tests.

Since Spring 4.3, if a class has only one constructor, the @Autowired annotation can even be omitted. The framework will automatically use that constructor for dependency injection.


12. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primay.

When you have multiple beans of the same type, and you want to inject one of them where a choice cannot be made based on the type, you can use the @Primary annotation. Spring gives preference to the bean marked with @Primary when resolving an autowiring conflict.

```aidl
@Configuration
public class MyConfig {

    @Bean
    @Primary
    public MyBeanClass myBeanPrimary() {
        return new MyBeanClass();
    }

    @Bean
    public MyBeanClass myBeanSecondary() {
        return new MyBeanClass();
    }
}
```

In this case, when you autowire MyBeanClass, the myBeanPrimary bean will be injected by default.
```aidl
@Autowired
private MyBeanClass myBean; // This will be myBeanPrimary

```

If you want to inject a specific bean in a certain situation, you can use the @Qualifier annotation. You can specify the name of the bean you want to inject. Here's an example:
```aidl
@Autowired
@Qualifier("myBeanSecondary")
private MyBeanClass myBean; // This will be myBeanSecondary
```

In this case, even though myBeanPrimary is marked as primary, myBeanSecondary will be injected because it's specified with @Qualifier. If no qualifier is given and no primary bean is set, Spring will throw a NoUniqueBeanDefinitionException because it doesn't know which bean to inject.


13. What is the difference between BeanFactory and ApplicationContext in Spring?

BeanFactory and ApplicationContext are two core interfaces in Spring that are used for configuring and managing beans.

BeanFactory is the root interface for accessing the Spring container. It provides basic Inversion of Control (IoC) and Dependency Injection (DI) features. BeanFactory is used when you need simple DI with no extra features like event propagation, declarative mechanisms, etc. It is lightweight and is ideal for simple scenarios.

ApplicationContext is a sub-interface of BeanFactory and it's usually the preferred interface to use. It adds more enterprise-centric functionality on top of the BeanFactory interface, such as:

- Easier integration with Spring's AOP features
- Message resource handling for use in internationalization
- Event propagation to beans implementing the ApplicationListener interface- 
- Loading of multiple (hierarchical) contexts, allowing each to be focused on one particular layer (for example, the web layer of an application)
- Support for Java EE features such as EJB, JMX, and basic remoting.

In essence, ApplicationContext is a complete superset of the BeanFactory and generally provides a richer feature set. However, BeanFactory can still be used for lightweight applications like mobile devices or applet-based applications where data volume and speed are significant.

In practical terms, you're most likely to interact with the ApplicationContext in a typical Spring application, often through its implementation such as ClassPathXmlApplicationContext or AnnotationConfigApplicationContext.


14. What is the Scope of a Bean? and list the examples for each scope.

In Spring, the scope of a bean defines the lifecycle and visibility of that bean in the contexts it is being used. Here are the different scopes of beans:

Singleton (default): Only one instance of the bean is created for each Spring container. This single instance is stored in a cache of such singleton beans, and all subsequent requests and references for that named bean return the cached instance.
```aidl
@Component
@Scope("singleton") // this is optional because singleton is the default scope
public class SingletonBean {
    // ...
}
```

Prototype: A new instance is created each time a bean is requested from the container. It's configured using @Scope("prototype").
```aidl
@Component
@Scope("prototype")
public class PrototypeBean {
    // ...
}
```

Request: A single instance of the bean is created for each HTTP request. This scope is only valid in the context of a web-aware Spring ApplicationContext.
```aidl
@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestScopedBean {
    // ...
}
```

Session: A single instance of the bean is created for each HTTP session. Like the request scope, this scope is only valid in the context of a web-aware Spring ApplicationContext.
```aidl
@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class SessionScopedBean {
    // ...
}
```

Application: A single instance of the bean is created for the lifecycle of a Servlet ServletContext. Like the request and session scopes, this scope is also only valid in the context of a web-aware Spring ApplicationContext.
```aidl
@Component
@Scope(value = WebApplicationContext.SCOPE_APPLICATION, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class ApplicationScopedBean {
    // ...
}
```

WebSocket: Scopes a single bean definition to the lifecycle of a WebSocket. This is only available with a web-aware ApplicationContext.
```aidl
@Component
@Scope(value = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class WebSocketScopedBean {
    // ...
}
```
Please note that proxyMode = ScopedProxyMode.TARGET_CLASS is needed for scopes other than singleton and prototype because by default Spring doesn't know when to create a new instance of your bean. Proxies tell Spring to create a new instance of the bean for each request/session/etc.


15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean? (you can google the tutorial how to configure beans in xml, and feel free to ask me any quesitons if you don't understand. it is a little bit old, I am not sure if I need to exaplain it in class)

The XML configuration is indeed a bit old, but it is still used in certain projects and it is a fundamental concept that helps understand how Spring works. To define beans in XML, you can use the <bean> tag inside a <beans> root element.
```aidl
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

    <bean id="myBean" class="com.example.MyBeanClass">
        <!-- Bean configuration -->
    </bean>

</beans>
```
In this example, myBean is the ID that will be used to refer to this bean in the Spring context. com.example.MyBeanClass is the fully-qualified name of the class for the bean.

If your bean has parameters/dependencies, you can set these using <constructor-arg> for constructor injection or <property> for setter injection. Here's an example:
```aidl
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

    <bean id="myDependency" class="com.example.MyDependencyClass" />

    <bean id="myBean" class="com.example.MyBeanClass">
        <!-- Inject myDependency using constructor injection -->
        <constructor-arg ref="myDependency" />

        <!-- Inject a string property using setter injection -->
        <property name="myProperty" value="someValue" />
    </bean>

</beans>
```
In this case, MyBeanClass should have a constructor that takes a MyDependencyClass object as an argument, and a setter method setMyProperty(String myProperty). Spring will automatically call these methods to inject the dependencies when it creates the myBean bean.

You can then load the XML configuration using ClassPathXmlApplicationContext or FileSystemXmlApplicationContext in your Java code:
```aidl
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
MyBeanClass myBean = context.getBean("myBean", MyBeanClass.class);
```



