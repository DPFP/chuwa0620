# HW2

## Q2: What are the checked exception and unchecked exception in Java, could you give one example?
`checked exception`: checked at compile time. e.g. `ClassNotFoundException`, `IOException`. <br>
`unchecked exception`: checked at runtime. e.g. `RuntimeException`, `IllegalArgumentException`. <br>

## Q3: Can there be multiple `finally` blocks?
No, there can be only one `finally` block for each try block.

## Q4: When both `catch` and `finally` return values, what will be the final result?
The final result will be the result returned from `finally`.

## Q5: What is Runtime/unchecked exception? what is Compile/Checked Exception?
**runtime exception**: a type of exception that is not checked at compile time. Instead, it happens while the program is running. These are typically problems that can occur due to programming errors, such as accessing an invalid array index, dividing by zero, or attempting to access a null object. <br>
**compile-time exception**:a type of exception that is checked at compile time. If some code within a method throws a checked exception, then the method must either handle the exception or it must specify the exception using the throws keyword. These are exceptional conditions that a well-written application should anticipate and recover from.

## Q6. What is the difference between `throw` and `throws`?
1. `throw`: used within a method, cannot throw multiple exceptions. 
2. `throws`:  declare an exception. It gives an indication to the developer about the exceptions that may occur. It is used with the signature of the method. It is used with a method signature and you can declare multiple exceptions using `throws` keyword.


## Q7. Run the below three pieces codes, Noticed the printed exceptions. why do we put the Null/Runtime exception before Exception?
We put `Null/Runtime exception` before `Exception` because the superclass `catch` block with `Exception` will catch all the exceptions and the subclass exceptions will never be caught.

## Q7. Why finally always be executed?
1. Resource deallocation.
2. To perform some action whether an exception was thrown or not.

## Q8. What are the types of design patterns in Java?


## Q9. What are the SOLID Principles?
1. **Single Responsibility Principle (SRP)**: a class should have only one reason to change.
2. **Open-Closed Principle (OCP)**: software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.
3. **Liskov Substitution Principle (LSP)**: if a program is using a base class, then the reference to the base class can be replaced with a derived class without affecting the program's correctness.
4. **Interface Segregation Principle (ISP)**: clients should not be forced to depend upon interfaces that they do not use. That means a class should not be forced to implement an interface if it doesn't use it.
5. **Dependency Inversion Principle (DIP)**: high-level modules should not depend on low-level modules.

## Q10. How can you achieve thread-safe singleton patterns in Java?
1. **Lazy initialization**
   ```
   public class Singleton {
        private static Singleton instance;
    
        public static synchronized Singleton getInstance() {
            if (instance == null) {
                instance = new Singleton();
            }
            return instance;
        }
    }
   ```
2. **Eager Initialization**
    ```
    public class Singleton {
        private static final Singleton instance = new Singleton();
        private Singleton() {}
    
        public static Singleton getInstance() {
            return instance;
        }
    }
    ```

## Q11. What do you understand by the Open-Closed Principle (OCP)?
OCP has two main concepts: 
1. **Open for extension**: New behavior can be added to satisfy new requirements. This is typically achieved through inheritance, where new derived classes are created from existing classes, or by implementing interfaces that define new behavior.
2. **Closed for modification**: Once the class is developed and tested, the code shouldn’t be touched. The existing code of such entities should not be modified when you want to add new functionalities or change the program behavior.

## Q12. (SOLID-L)Liskov’s substitution principle states that if class B is a subtype of class A, then an object of type A may be substituted with any object of type B. What does this actually mean? (from OA ) choose your answer.

This means that if object B is a subtype of object A, it must be a subclass of object A that doesn't violate any behavior of object A. <br>
 LSP helps ensure that a subclass can stand in for its superclass without causing any functionality issues or side effects. <br>
 If the LSP is violated, it can lead to strange bugs in the program, since behavior can change unexpectedly when a superclass is swapped out for a subclass.


