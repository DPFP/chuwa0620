## HW2
### Name: Yuanzhen Lin

### 1. Practice collection
In /coding/practice directory

###2. What is the checked exception and unchecked exception in Java, could you give one example?
- Checked Exceptions:\
These are the exceptions that are checked at compile time. If some code within a method throws a checked exception, then the method must either handle the exception or it must specify the exception using throws keyword. Checked exceptions are typically used for recoverable conditions, such as File not found error or I/O error.
```
public static void main(String[] args){
    try {
        FileReader file = new FileReader("file.text");
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
}
```
- Unchecked Exceptions:\
These are exceptions that are not checked at compile time. Unchecked exceptions are also called Runtime Exceptions. They are typically programming errors such as logic errors or improper use of an API. RuntimeException is the superclass of all the exceptions which may be thrown during the execution of a program.
```
public static void main(String[] args) {
        int value = 7;
        value = value / 0; // ArithmeticException here
}
```

###3. Can there be multiple finally blocks?
No, there cannot be multiple finally blocks for a single try block in Java. A try block can be followed by zero or more catch blocks and zero or one finally block.

###4. When both catch and finally return values,what will be the final result?
It will end up returning the value from the finally block. This is because the finally block is always executed after the try and catch blocks, regardless of whether an exception was thrown and handled.

### 5. What is Runtime/unchecked exception? what is Compile/Checked Exception?
- Checked Exceptions:\
  These are the exceptions that are checked at compile time. If some code within a method throws a checked exception, then the method must either handle the exception or it must specify the exception using throws keyword. Checked exceptions are typically used for recoverable conditions, such as File not found error or I/O error.
- Unchecked Exceptions:\
  These are exceptions that are not checked at compile time. Unchecked exceptions are also called Runtime Exceptions. They are typically programming errors such as logic errors or improper use of an API. RuntimeException is the superclass of all the exceptions which may be thrown during the execution of a program.

### 6. What is the difference between throw and throws?
- throw:\
throw keyword is used to explicitly throw an exception from a method or any block of code. We can throw either checked or unchecked exception. The throw keyword is followed by an instance of a class derived from Throwable class.
- throws:\
  The throws keyword is used in method signatures to declare the exceptions that the method might throw. The caller to these methods has to handle the exception using a try-catch block or propagate it further up the call stack (also using throws). The throws keyword is followed by the class of Exception that might be thrown.

### 7. Run the below three pieces codes,Noticed the printed exceptions.why do we put the Null/Runtime exception before Exception ?
If you put a catch block for Exception before other catch blocks for more specific exceptions, then the catch block for Exception would handle all types of exceptions, because Exception is the superclass of all exceptions in Java. Then you could not distinguish the specific Exception reason for the code.

### 7. Why finally always be executed?
The finally block in Java provides a mechanism to ensure that cleanup code is always executed, regardless of how the code within the try block is exited. This makes it an excellent tool for resource management, where resources like database connections, files, or network connections need to be properly closed even if an exception is thrown.

### 8. What are the types of design patterns in Java?
1. Creational Design Patterns: 
These patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. They provide a way to create objects while hiding the creation logic, rather than instantiating objects directly using the new operator. This gives the program more flexibility in deciding which objects need to be created for a given situation. Examples include Singleton, Factory Method, Abstract Factory, Prototype, and Builder.
2. Structural Design Patterns:
   These patterns deal with the composition of classes or objects to form larger structures. They explain how to assemble objects and classes into larger structures while keeping the structures flexible and efficient. Examples include Adapter, Decorator, Proxy, Composite, Bridge, and Facade.
3. Behavioral Design Patterns:
   These patterns are specifically concerned with communication between objects, how objects interact and how to divide responsibilities between objects. They describe not just patterns of objects or classes but also the patterns of communication between them. Examples include Observer, State, Strategy, Template Method, Visitor, Command, and Iterator.

### 9. What are the SOLID Principles?
The SOLID principles are a set of five principles in object-oriented programming and design. They were introduced by Robert C. Martin (also known as Uncle Bob), and are intended to make software designs more understandable, flexible, and maintainable.
1. Single Responsibility Principle (SRP):\
A class should have one, and only one, reason to change. This means a class should only have one job or responsibility. For example, a Customer class should only be responsible for properties and operations related to a customer and not be responsible for persisting itself to a database - that would be the responsibility of a separate class.
2. Open-Closed Principle (OCP):\
Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. This means that a class should be extendable without modifying the class itself. This can often be achieved using inheritance and/or interfaces.
3. Liskov Substitution Principle (LSP):\
Subtypes must be substitutable for their base types. This means that if a program is using a base class, it should be able to use any of its subclasses without the program knowing it, or in other words, without breaking the program.
4. Interface Segregation Principle (ISP):\
Clients should not be forced to depend on interfaces they do not use. This principle deals with the disadvantages of "fat" interfaces. Classes that have "fat" interfaces are classes whose interfaces are not cohesive. In other words, the interfaces of the class can be broken up into groups of member functions. Each group serves a different set of clients. Thus, some clients use one group of member functions, and other clients use the other groups.
5. Dependency Inversion Principle (DIP):\
High-level modules should not depend on low-level modules. Both should depend on abstractions. This means that high-level modules, which provide complex logic, should be easily reusable and unaffected by changes in low-level modules, which provide utility features. To achieve that, you need to introduce an abstraction that decouples the high-level and low-level modules from each other.

### 10. How can you achieve thread-safe singleton patterns in Java ?
1. Synchronization\
We can make the getInstance() method synchronized, which ensures that only one thread can execute this method at a time.
```
public class Singleton {
  private static Singleton instance;
  private Singleton(){}
  public static synchronized Singleton getInstance(){
    if(instance == null){
      instance = new Singleton();
    }
    return instance;
  }
}
```
2. Bill Pugh Singleton (Initialization-on-demand holder idiom):\
This approach uses a private static inner class to hold the singleton instance. The instance is created when the inner class is loaded, but the inner class is not loaded until the getInstance() method is invoked. This approach is thread-safe and also more efficient than synchronization.
```
public class Singleton {
  private static Singleton(){}
  private static class Holder {
    private static final Singleton INSTANCE = new Singleton();
  }
  public static Singleton getInstance(){
    return Holder.INSTANCE;
  }
}
```
3. Enum Singleton:\
   The simplest way is to use an enum, which is inherently thread-safe. The Singleton property is guaranteed by the JVM.
```
public enum Singleton {
  INSTANCE;
}
```
We can access the singleton instance with Singleton.INSTANCE and call methods like Singleton.INSTANCE.someMethod().

### 11. What do you understand by the Open-Closed Principle (OCP) ?
The principle states that: "Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification."
- Open for extension:\
This means that the behavior of a module can be extended. As the requirements of the application change, we are able to add new features or modify existing ones by adding new code, not by changing existing code
- Closed for modification:\
Once the module has been developed and tested, the source code is not allowed to be modified to add new functionality. Any new functionality should be added as new classes that use the base classes of the module.

### 12. (SOLID-L)Liskovâ€™s substitution principle states that if class B is a subtype of class A, then object of type A may be substituted with any object of type B. What does this actually mean? (from OA ) choose your answer.
Choose answer 1.
1. It means that if the object of type A can do something,the object of type B could also be able to perform the same thing
2. It means that all the objects of type A could execute all the methods present in its subtypeB
3. It means if a method is present in class A, it should also be present in class B so that the object of type B could substitute object of type A.
4. It means that for the class B to inherit class A,objects of type B and objects of type A must be same.

