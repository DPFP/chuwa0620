# HW10
### Name: Yuanzhen Lin

1. List all of the annotations you learned from class and homework to annotaitons.md\
See the annotations.md file.

2. Type the Comment feature for the class project.\
Look at Coding1/comment.

3. In postman, call of the APIs in PostController and CommentController.\
Call it.

4. what is JPA? and what is Hibernate?
- JPA\
The Java Persistence API (JPA) is a Java specification that provides certain standards to persist data between Java objects and relational databases (like MySQL, PostgreSQL, etc.). JPA describes the management of relational data in applications using Java Platform, Standard Edition, and Java Platform, Enterprise Edition.\
JPA provides a way to map Java classes to database tables and the instances of those classes (objects) to rows in those tables. It also specifies how relationships between these objects are mapped to relationships between tables (like One-To-Many, One-To-One, Many-To-One, and Many-To-Many).

- Hibernate:\
Hibernate ORM (Object-Relational Mapping) is an open-source implementation of the JPA. Hibernate provides a framework for mapping an object-oriented domain model to a traditional relational database. This technique of mapping Java classes to database tables and Java data types to SQL data types is called "Object-Relational Mapping" (ORM).\
While JPA is a standard/interface, Hibernate is a JPA provider that implements the API. Hibernate goes beyond the JPA standard and provides additional features on top of JPA.

In summary, you can consider JPA as a set of rules for storing Java objects in a database, and Hibernate is a tool that follows those rules and provides additional functionality.

5. What is Hiraki? what is the benefits of connection pool?\
HikariCP is a very fast, reliable, and lightweight JDBC connection pool. Connection pooling is a technique of creating and managing a pool of connections that are already established to a database.\
Here are the benefits of using a connection pool like HikariCP:
- Reduced Connection Time: \
Establishing a connection with a database is a costly operation in terms of time and resources. When a connection is returned to the pool, it's not closed but rather kept alive so it can be reused, which can significantly speed up consecutive database operations.

- Maximized Resource Utilization: \
Connection pools are usually bounded, meaning they have a maximum number of connections that they can hold. This can prevent an application from exhausting system resources by creating too many connections.

- Improved Performance: \
The ability to reuse existing connections and control how many connections are created can significantly improve the performance of database operations.

- Control over Concurrency: \
Connection pools can limit the number of concurrent database connections, which can be useful in high-load scenarios.

HikariCP is often chosen for its performance and simplicity. It's built with a "zero-overhead" philosophy and has a focus on tracking and resolving issues that can impact performance or stability. HikariCP also provides a lot of metrics which can be very useful for monitoring and debugging.

6. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.
@OneToMany, @ManyToOne, and @ManyToMany are annotations used in JPA (Java Persistence API) to define relationships between entities.\
- @OneToMany: \
This annotation defines a many-to-one relationship from the entity in the current class to the entity in another class.
```aidl
@Entity
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @OneToMany(mappedBy = "post", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Comment> comments;
}

@Entity
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id")
    private Post post;
}
```

- @ManyToOne: \
This annotation defines a many-to-one relationship from the entity in the current class to the entity in another class. In the above example, @ManyToOne is used in the Comment class to indicate that many comments can belong to one post.

- @ManyToMany: \
This annotation is used when many entities of one type can be related to many entities of another type.
```aidl
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @ManyToMany(cascade = { CascadeType.ALL })
    @JoinTable(
        name = "Student_Course", 
        joinColumns = { @JoinColumn(name = "student_id") }, 
        inverseJoinColumns = { @JoinColumn(name = "course_id") }
    )
    private List<Course> courses;
}

@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @ManyToMany(mappedBy = "courses")
    private List<Student> students;
}
```


7. What is the cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?\
CascadeType and orphanRemoval are two options that you can use to manage the entities in the "one" side of a relationship when an operation is performed on the "many" side.
- CascadeType: \
This setting determines which operations that are performed on the "many" side of a relationship should be automatically cascaded to the "one" side. Here are the different cascade types:
  - ALL: All operations (PERSIST, MERGE, REMOVE, REFRESH, DETACH) are cascaded.

  - PERSIST: The persist operation is cascaded. When you save the "many" side, the "one" side gets saved as well.

  - MERGE: The merge operation is cascaded. When you update the "many" side, the "one" side gets updated as well.

  - REMOVE: The remove operation is cascaded. When you delete the "many" side, the "one" side gets deleted as well.

  - REFRESH: The refresh operation is cascaded. If you refresh the "many" side, the "one" side gets refreshed as well.

  - DETACH: The detach operation is cascaded. When you detach the "many" side, the "one" side gets detached as well.

- orphanRemoval: \
This setting determines whether an entity that is no longer referenced from the "many" side of a relationship should be automatically deleted.
  - If orphanRemoval is true, and an entity on the "one" side of the relationship is no longer referenced from the "many" side, it will be removed from the database.
  - If orphanRemoval is false (the default), then it will not be removed.

8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?\
FetchType.LAZY and FetchType.EAGER are hints to the persistence provider (like Hibernate) about when to load the related entities.
- FetchType.LAZY: \
This means that the related entities should be fetched lazily, i.e., they should not be fetched from the database until they are explicitly accessed in the application. This is beneficial when you have a large number of related entities and you don't need them immediately. Lazy loading helps to improve the performance of the application by reducing the memory requirements and the load on the database.

- FetchType.EAGER: \
This means that the related entities should be fetched from the database immediately, along with the entity that refers to them. Eager fetching can be useful when you are sure that you will need the related entities for further operations, and you'd like to fetch them in a single database call to avoid multiple round trips to the database.

Choosing between LAZY and EAGER depends on your application's needs. If you have a one-to-many relationship where the 'many' side can have a lot of entities (like a Post with many Comments), you would typically choose LAZY to avoid loading all comments when you fetch a Post. However, if you have a relationship where the 'many' side usually contains only a few entities (like a User with several Roles), EAGER fetching might make sense because you are likely to need the roles whenever you deal with a user.

The default fetch type for @OneToMany and @ManyToMany relationships is LAZY, while for @OneToOne and @ManyToOne it's EAGER. However, it's generally recommended to use LAZY for all associations and override this to EAGER on a query-by-query basis when necessary. This ensures that you only fetch eagerly when you know that you're going to use the data, preventing unnecessary database hits.

Remember that how LAZY and EAGER fetch types work also depend on the specific behavior of the JPA provider (like Hibernate). Some providers might not fully respect these hints, especially for LAZY fetching.


9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?\
JPA provides a way to implement simple query methods without having to write any SQL or JPQL. By following certain naming conventions for method names in your repository interface, you can define a query method and the actual query will be automatically generated for you by Spring Data JPA.\
Here are some rules for the naming convention:
- The method name must start with find, get, read, count, exists, delete, or remove.
- The next part of the method name is By which is used to express a predicate over entities.
- After the By keyword, you can add property expressions, optionally connected with And or Or

Here are some examples of method names and what they do:
- findByName(String name): This would generate a query that finds entities where the name property is equal to the passed argument.
- findByNameAndAge(String name, int age): This would generate a query that finds entities where the name property is equal to the first argument and the age property is equal to the second argument.
- findByNameOrAge(String name, int age): This would generate a query that finds entities where either the name property is equal to the first argument or the age property is equal to the second argument.
- countByName(String name): This would generate a query that counts the number of entities with the name property equal to the passed argument.
- deleteByName(String name): This would generate a query that deletes entities with the name property equal to the passed argument.
- findByNameOrderByIdDesc(String name): This would generate a query that finds entities with the name property equal to the passed argument, ordered by id in descending order.

When you need more complex queries that cannot be expressed with the naming convention, you can use the @Query annotation to define custom JPQL or native SQL queries.


10. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.












