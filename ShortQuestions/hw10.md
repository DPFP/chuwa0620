# Chuwa0620 HW10
### Zhizhou Xu

1. See in annotation.md  
2. See in redbook project  
3. Done
4. What is JPA? and what is Hibernate?  
   JPA is a Java specification that defines a standard for object-relational mapping, while Hibernate is an implementation of the JPA specification, offering additional features and optimizations. By using Hibernate as the JPA provider, developers can write database-independent code that can be easily switched to other JPA providers if needed, making it easier to develop and maintain Java applications with persistence requirements.  
5. What is Hiraki? what is the benefits of connection pool?  
   HikariCP (not "Hiraki") is a popular connection pooling library for Java applications, and using a connection pool like HikariCP provides various benefits, including improved performance, resource management, and optimized connection usage.  
6. What is the `@OneToMany`, `@ManyToOne`, `@ManyToMany`? write some examples.  
    1. `@OneToMany`:
       `@OneToMany` is used to define a one-to-many relationship between two entities, where one entity (the parent) has multiple related entities (the children).
       In a database, this relationship is typically represented by a foreign key in the child table that refers to the primary key in the parent table.  
    ```java
    @Entity
    public class Parent {
        @Id
        private Long id;
        @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
        private List<Child> children;
    }
    
    @Entity
    public class Child {
        @Id
        private Long id;
        @ManyToOne
        @JoinColumn(name = "parent_id")
        private Parent parent;
    }
   ```  
   2. `@ManyToOne`:
      `@ManyToOne` is used to define a many-to-one relationship between two entities, where multiple entities (the children) are related to a single entity (the parent).
      This relationship is represented in the database by a foreign key in the child table that refers to the primary key in the parent table.  
   ```java
    @Entity
    public class Order {
        @Id
        private Long id;
        @ManyToOne
        @JoinColumn(name = "customer_id")
        private Customer customer;
    }
    
    @Entity
    public class Customer {
        @Id
        private Long id;
        @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL)
        private List<Order> orders;
    }
   ```  
   3. `@ManyToMany`:
      `@ManyToMany` is used to define a many-to-many relationship between two entities, where multiple entities from both sides can be related to each other.
      In a database, a many-to-many relationship is typically represented using an additional join table that stores the associations between the entities.  
   ```java
   @Entity
    public class Student {
        @Id
        private Long id;
        @ManyToMany
        @JoinTable(
            name = "enrollments",
            joinColumns = @JoinColumn(name = "student_id"),
            inverseJoinColumns = @JoinColumn(name = "course_id")
        )
        private List<Course> courses;
    }
    
    @Entity
    public class Course {
        @Id
        private Long id;
        @ManyToMany(mappedBy = "courses")
        private List<Student> students;
    }
   ```  
7. What is the  cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?  
   `cascade = CascadeType.ALL`: Cascades all operations (persist, merge, remove, refresh, detach) from the parent entity to the associated child entities.  
   `orphanRemoval = true`: Automatically deletes orphaned child entities when they are disassociated from the parent entity.  

   Other CascadeType options:

   `PERSIST`: Cascades the `persist()` operation to the associated child entities.  
   `MERGE`: Cascades the `merge()` operation to the associated child entities.  
   `REMOVE`: Cascades the `remove()` operation to the associated child entities.  
   `REFRESH`: Cascades the `refresh()` operation to the associated child entities.  
   `DETACH`: Cascades the `detach()` operation to the associated child entities.  
8. What is the  fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?  
   `fetch = FetchType.LAZY`: Associated entities are not loaded from the database immediately when the parent entity is fetched. They are fetched only when explicitly accessed in the code. Useful for large relationships to minimize initial query overhead.  
   `fetch = FetchType.EAGER`: Associated entities are loaded from the database immediately along with the parent entity. Useful when the associated entities are frequently accessed together with the parent entity or when the associated data is small and doesn't impact performance significantly.  
9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?  
   JPA naming convention automatically derives table and column names from Java class and property names. You can customize the names using annotations if needed, but JPA handles most of the mapping automatically, reducing the need for manual configuration.   
10. Done  
11. Optional  
12. Optional  
13. Done  
14. What is JPQL?  
    JPQL (Java Persistence Query Language) is a platform-independent query language used to perform database operations in JPA (Java Persistence API) applications.  
15. What is `@NamedQuery` and `@NamedQueries`?  
    `@NamedQuery` and `@NamedQueries` are annotations used in JPA (Java Persistence API) to define named queries. Named queries allow developers to pre-define JPQL queries and associate them with entity classes. These queries can then be easily reused in different parts of the application.  
16. What is `@Query`? In which Interface we write the sql or JPQL?  
    `@Query` is an annotation provided by Spring Data JPA that allows you to define custom queries directly in the repository interface. It provides a way to write SQL or JPQL (Java Persistence Query Language) queries within your repository methods without the need for implementing those queries in separate XML or properties files.  
17. What is HQL and Criteria Queries?  
    1. HQL (Hibernate Query Language):  
    HQL is similar to SQL but operates on entity classes and their properties in Hibernate.
    It allows database-agnostic queries and is translated to SQL by Hibernate.
    HQL queries are defined using createQuery().
    2. Criteria Queries:  
    Criteria Queries provide a programmatic, type-safe API in Hibernate.
    They are useful for dynamically constructing queries.
    Criteria Queries are defined using CriteriaBuilder and CriteriaQuery.
18. What is EntityManager?  
    The EntityManager is a core interface in the Java Persistence API (JPA) that provides the primary operations for interacting with the database in a JPA-based application. It serves as the entry point to the persistence context, which is the set of managed entity instances representing the state of the database.  
19. What is SessionFactory and Session?  
    They are responsible for managing the interaction between the Java application and the database.  
20. What is Transaction? how to manage your transaction?  
    A transaction is a sequence of one or more database operations that are executed as a single unit of work. Transactions ensure that a group of related operations either succeed as a whole or fail as a whole, maintaining data integrity and consistency.  
21. What is hibernate Caching?  
    1. First-level Cache: Associated with the Session, stores recently queried or persisted entities. Short-lived, cleared when the session is closed.
    2. Second-level Cache: Shared cache across sessions, reduces database load, can store entity instances, query results, and other objects.  
22. What is the difference between first-level cache and second-level cache?  
    1. First-level Cache: Associated with the Session, stores recently queried or persisted entities. Short-lived, cleared when the session is closed.
    2. Second-level Cache: Shared cache across sessions, reduces database load, can store entity instances, query results, and other objects.  
23. How do you understand @Transactional?  
This annotation makes it easier to handle a transaction. There is no need to write try catch blocks and it will handle the commit and rollback automatically.  
24. Write a simple factory design pattern.  
```java
public interface Shape {
    void draw();
}

public class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a circle");
    }
}

public class Square implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a square");
    }
}

public class Triangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a triangle");
    }
}

public class ShapeFactory {
    public Shape createShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }

        if (shapeType.equalsIgnoreCase("Circle")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("Square")) {
            return new Square();
        } else if (shapeType.equalsIgnoreCase("Triangle")) {
            return new Triangle();
        }

        return null;
    }
}
```
1. Done  
2. what is the @configuration and @bean?  
   `@Configuration`:  
    Indicates that a Java class contains configuration methods for creating Spring beans.  
    Used in conjunction with `@Bean` methods to manually define and register beans.  
    `@Bean`:  
    Declares a method as a bean definition method inside a `@Configuration` class.
    The method's return value is registered as a Spring bean in the application context.  
3. How do you handle the exception in Spring?  
   `@ExceptionHandler`: Annotate methods in a controller to handle specific exceptions within that controller.  
    `@ControllerAdvice`: Define global exception handling across multiple controllers using this annotation.  
4. How do you do the validations in Spring? And list some validation annotations you know.  
   `@NotNull`: The annotated element must not be null.  
   `@NotEmpty`: The annotated string, collection, or array must not be empty.  
   `@NotBlank`: The annotated string must not be null or whitespace.  
   `@Min(value)`: The annotated element must be a number whose value is higher than or equal to the specified minimum value.  
   `@Max(value)`: The annotated element must be a number whose value is lower than or equal to the specified maximum value.  
   `@Size(min, max)`: The annotated string, collection, or array must have a size between the specified minimum and maximum values.  
    Use these annotations to set rules in entity classes and then use `@Validate` in Controllers to validate these rules.  
5. What is the actuator?  
   Spring Boot Actuator is a subproject of the Spring Boot framework that provides production-ready features to help monitor and manage Spring Boot applications. 