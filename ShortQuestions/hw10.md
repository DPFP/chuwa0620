# HW10
### Name: Yuanzhen Lin

1. List all of the annotations you learned from class and homework to annotaitons.md\
See the annotations.md file.

2. Type the Comment feature for the class project.\
Look at Coding1/comment.

3. In postman, call of the APIs in PostController and CommentController.\
Call it.

4. what is JPA? and what is Hibernate?
- JPA\
The Java Persistence API (JPA) is a Java specification that provides certain standards to persist data between Java objects and relational databases (like MySQL, PostgreSQL, etc.). JPA describes the management of relational data in applications using Java Platform, Standard Edition, and Java Platform, Enterprise Edition.\
JPA provides a way to map Java classes to database tables and the instances of those classes (objects) to rows in those tables. It also specifies how relationships between these objects are mapped to relationships between tables (like One-To-Many, One-To-One, Many-To-One, and Many-To-Many).

- Hibernate:\
Hibernate ORM (Object-Relational Mapping) is an open-source implementation of the JPA. Hibernate provides a framework for mapping an object-oriented domain model to a traditional relational database. This technique of mapping Java classes to database tables and Java data types to SQL data types is called "Object-Relational Mapping" (ORM).\
While JPA is a standard/interface, Hibernate is a JPA provider that implements the API. Hibernate goes beyond the JPA standard and provides additional features on top of JPA.

In summary, you can consider JPA as a set of rules for storing Java objects in a database, and Hibernate is a tool that follows those rules and provides additional functionality.

5. What is Hiraki? what is the benefits of connection pool?\
HikariCP is a very fast, reliable, and lightweight JDBC connection pool. Connection pooling is a technique of creating and managing a pool of connections that are already established to a database.\
Here are the benefits of using a connection pool like HikariCP:
- Reduced Connection Time: \
Establishing a connection with a database is a costly operation in terms of time and resources. When a connection is returned to the pool, it's not closed but rather kept alive so it can be reused, which can significantly speed up consecutive database operations.

- Maximized Resource Utilization: \
Connection pools are usually bounded, meaning they have a maximum number of connections that they can hold. This can prevent an application from exhausting system resources by creating too many connections.

- Improved Performance: \
The ability to reuse existing connections and control how many connections are created can significantly improve the performance of database operations.

- Control over Concurrency: \
Connection pools can limit the number of concurrent database connections, which can be useful in high-load scenarios.

HikariCP is often chosen for its performance and simplicity. It's built with a "zero-overhead" philosophy and has a focus on tracking and resolving issues that can impact performance or stability. HikariCP also provides a lot of metrics which can be very useful for monitoring and debugging.

6. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.
@OneToMany, @ManyToOne, and @ManyToMany are annotations used in JPA (Java Persistence API) to define relationships between entities.\
- @OneToMany: \
This annotation defines a many-to-one relationship from the entity in the current class to the entity in another class.
```aidl
@Entity
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @OneToMany(mappedBy = "post", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Comment> comments;
}

@Entity
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id")
    private Post post;
}
```

- @ManyToOne: \
This annotation defines a many-to-one relationship from the entity in the current class to the entity in another class. In the above example, @ManyToOne is used in the Comment class to indicate that many comments can belong to one post.

- @ManyToMany: \
This annotation is used when many entities of one type can be related to many entities of another type.
```aidl
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @ManyToMany(cascade = { CascadeType.ALL })
    @JoinTable(
        name = "Student_Course", 
        joinColumns = { @JoinColumn(name = "student_id") }, 
        inverseJoinColumns = { @JoinColumn(name = "course_id") }
    )
    private List<Course> courses;
}

@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @ManyToMany(mappedBy = "courses")
    private List<Student> students;
}
```


7. What is the cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?\
CascadeType and orphanRemoval are two options that you can use to manage the entities in the "one" side of a relationship when an operation is performed on the "many" side.
- CascadeType: \
This setting determines which operations that are performed on the "many" side of a relationship should be automatically cascaded to the "one" side. Here are the different cascade types:
  - ALL: All operations (PERSIST, MERGE, REMOVE, REFRESH, DETACH) are cascaded.

  - PERSIST: The persist operation is cascaded. When you save the "many" side, the "one" side gets saved as well.

  - MERGE: The merge operation is cascaded. When you update the "many" side, the "one" side gets updated as well.

  - REMOVE: The remove operation is cascaded. When you delete the "many" side, the "one" side gets deleted as well.

  - REFRESH: The refresh operation is cascaded. If you refresh the "many" side, the "one" side gets refreshed as well.

  - DETACH: The detach operation is cascaded. When you detach the "many" side, the "one" side gets detached as well.

- orphanRemoval: \
This setting determines whether an entity that is no longer referenced from the "many" side of a relationship should be automatically deleted.
  - If orphanRemoval is true, and an entity on the "one" side of the relationship is no longer referenced from the "many" side, it will be removed from the database.
  - If orphanRemoval is false (the default), then it will not be removed.

8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?\
FetchType.LAZY and FetchType.EAGER are hints to the persistence provider (like Hibernate) about when to load the related entities.
- FetchType.LAZY: \
This means that the related entities should be fetched lazily, i.e., they should not be fetched from the database until they are explicitly accessed in the application. This is beneficial when you have a large number of related entities and you don't need them immediately. Lazy loading helps to improve the performance of the application by reducing the memory requirements and the load on the database.

- FetchType.EAGER: \
This means that the related entities should be fetched from the database immediately, along with the entity that refers to them. Eager fetching can be useful when you are sure that you will need the related entities for further operations, and you'd like to fetch them in a single database call to avoid multiple round trips to the database.

Choosing between LAZY and EAGER depends on your application's needs. If you have a one-to-many relationship where the 'many' side can have a lot of entities (like a Post with many Comments), you would typically choose LAZY to avoid loading all comments when you fetch a Post. However, if you have a relationship where the 'many' side usually contains only a few entities (like a User with several Roles), EAGER fetching might make sense because you are likely to need the roles whenever you deal with a user.

The default fetch type for @OneToMany and @ManyToMany relationships is LAZY, while for @OneToOne and @ManyToOne it's EAGER. However, it's generally recommended to use LAZY for all associations and override this to EAGER on a query-by-query basis when necessary. This ensures that you only fetch eagerly when you know that you're going to use the data, preventing unnecessary database hits.

Remember that how LAZY and EAGER fetch types work also depend on the specific behavior of the JPA provider (like Hibernate). Some providers might not fully respect these hints, especially for LAZY fetching.


9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?\
JPA provides a way to implement simple query methods without having to write any SQL or JPQL. By following certain naming conventions for method names in your repository interface, you can define a query method and the actual query will be automatically generated for you by Spring Data JPA.\
Here are some rules for the naming convention:
- The method name must start with find, get, read, count, exists, delete, or remove.
- The next part of the method name is By which is used to express a predicate over entities.
- After the By keyword, you can add property expressions, optionally connected with And or Or

Here are some examples of method names and what they do:
- findByName(String name): This would generate a query that finds entities where the name property is equal to the passed argument.
- findByNameAndAge(String name, int age): This would generate a query that finds entities where the name property is equal to the first argument and the age property is equal to the second argument.
- findByNameOrAge(String name, int age): This would generate a query that finds entities where either the name property is equal to the first argument or the age property is equal to the second argument.
- countByName(String name): This would generate a query that counts the number of entities with the name property equal to the passed argument.
- deleteByName(String name): This would generate a query that deletes entities with the name property equal to the passed argument.
- findByNameOrderByIdDesc(String name): This would generate a query that finds entities with the name property equal to the passed argument, ordered by id in descending order.

When you need more complex queries that cannot be expressed with the naming convention, you can use the @Query annotation to define custom JPQL or native SQL queries.


10. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.\
Look at MavenProject/redbook

11. (Optional) Check out a new branch(https://github.com/TAIsRich/springboot-red book/tree/hw02_01_jdbcTemplate) from branch 02_post_RUD, replace the dao layer using JdbcTemplate\
Done

12. (Optional) use JDBC to read the data from database.、
Done

13. type the code, you need to checkout new branch from branch 02_post_RUD, name the new branch with https://github.com/TAIsRich/springboot-redbook/ tree/hw05_01_slides_JPQL.\
In MavenProject/springboot-redbook-hw05_01_slides_JPQL


14. What is JPQL?

JPQL stands for Java Persistence Query Language. It is a platform-independent object-oriented query language defined as part of the Java Persistence API (JPA) specification. It's used to query, store, update, and retrieve objects from a database in a way that is independent of the underlying database schema and the relational database aspects.

In other words, JPQL is used to make queries against entities stored in a relational database. It is heavily inspired by SQL, and its queries resemble SQL queries in syntax, but operate on JPA entity objects rather than directly on database tables.

The key difference between SQL and JPQL is that SQL operates on database tables, records and fields, while JPQL operates on Java classes and instances. JPQL understands object-oriented concepts such as inheritance, polymorphism, and associations which are common in Java, but have no direct correlation in SQL.

Here is an example of a simple JPQL query:
```aidl
String queryString = "SELECT e FROM Employee e WHERE e.firstName = :fname and e.lastName = :lname";
TypedQuery<Employee> query = em.createQuery(queryString, Employee.class);
query.setParameter("fname", "John");
query.setParameter("lname", "Doe");
List<Employee> results = query.getResultList();
```

In this example, the Employee in the SELECT clause refers to the Employee Java entity, not the underlying database table. The fields firstName and lastName are also fields in the Employee entity class, not columns in the database table.

Remember that JPQL is a key feature of JPA, which is a standard specification. This means that you can use JPQL across different JPA implementations like Hibernate, EclipseLink, etc.


15. What is @NamedQuery and @NamedQueries?

@NamedQuery and @NamedQueries are annotations used in the Java Persistence API (JPA) and Hibernate to declare queries in the entity class itself rather than in the code where they're used.

@NamedQuery: It's used to declare a single named, static query. This query is associated with a JPA entity or mapped superclass. The main advantage of this annotation is that it allows a query to be defined in one place and then be used in multiple places, which makes it easy to maintain. Here's an example:
```
@Entity
@NamedQuery(
  name="findCustomerByName",
  query="SELECT c FROM Customer c WHERE c.name LIKE :custName"
)
public class Customer {
  // ...
}
```

You can then use the named query like this:
```aidl
TypedQuery<Customer> query = em.createNamedQuery("findCustomerByName", Customer.class);
query.setParameter("custName", "John%");
List<Customer> results = query.getResultList();
```

@NamedQueries: This is used to group multiple @NamedQuery annotations. If you have several named queries for an entity, it's more organized to group them together with @NamedQueries. Here's an example:
```aidl
@Entity
@NamedQueries({
  @NamedQuery(
    name="findCustomerByName",
    query="SELECT c FROM Customer c WHERE c.name LIKE :custName"
  ),
  @NamedQuery(
    name="findCustomerByCity",
    query="SELECT c FROM Customer c WHERE c.city = :city"
  )
})
public class Customer {
  // ...
}
```

You can then use these named queries like you would use a single named query. For example:
```aidl
TypedQuery<Customer> queryByName = em.createNamedQuery("findCustomerByName", Customer.class);
queryByName.setParameter("custName", "John%");
List<Customer> resultsByName = queryByName.getResultList();

TypedQuery<Customer> queryByCity = em.createNamedQuery("findCustomerByCity", Customer.class);
queryByCity.setParameter("city", "New York");
List<Customer> resultsByCity = queryByCity.getResultList();
```
Named queries improve code organization by separating the JPQL query strings from the business logic. They're also parsed when the entity manager factory is created, making the application fail fast in case of a query error.

16. What is @Query? In which Interface we write the sql or JPQL?

@Query is an annotation used in Spring Data JPA to declare JPQL (Java Persistence Query Language) and native SQL queries directly on repository methods.

The @Query annotation allows for running complex queries which cannot be addressed by Spring Data's query derivation mechanism, where queries are constructed automatically from method names.

Here is an example of a method inside a Spring Data JPA repository using the @Query annotation:
```aidl
public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT u FROM User u WHERE u.email = ?1")
    User findByEmail(String email);

    @Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1", nativeQuery = true)
    User findByEmailAddressNative(String emailAddress);
}
```

In the first method, findByEmail(String email), we're using a JPQL query to fetch a user by their email address.

In the second method, findByEmailAddressNative(String emailAddress), we're using a native SQL query to fetch a user by their email address. The nativeQuery attribute is set to true to let Spring Data JPA know that this is a native SQL query, not a JPQL query.

These custom queries using @Query are usually written in the repository interfaces that extend JpaRepository or CrudRepository in the Spring Data JPA framework.


17. What is HQL and Criteria Queries?
- HQL (Hibernate Query Language):

HQL is a query language that is similar in many ways to SQL. It's fully object-oriented and understands concepts like inheritance, polymorphism, and association, which makes it more suited to querying data in an object-oriented way compared to SQL.

An example of an HQL query:
```aidl
String hql = "FROM Employee E WHERE E.id = 10";
Query query = session.createQuery(hql);
List results = query.list();
```

- Criteria Queries:

Criteria Queries are a type of query provided by Hibernate as an alternative to writing HQL or native SQL queries. They provide a type-safe, programmatic, object-oriented way of expressing a query. With Criteria Queries, you construct a query by instantiating and manipulating a Criteria object, which is a high-level API that Hibernate provides for queries.

An example of a Criteria Query:

```
CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery<Employee> cq = cb.createQuery(Employee.class);
Root<Employee> employee = cq.from(Employee.class);
cq.select(employee);
TypedQuery<Employee> query = entityManager.createQuery(cq);
List<Employee> employees = query.getResultList();
```

Criteria Queries are more verbose than HQL or SQL but they have the advantage of being checked for errors at compile time because of their object-oriented API, which can prevent runtime errors that might occur with string-based HQL or SQL queries.

Both HQL and Criteria Queries provide ways to create complex queries beyond simple CRUD operations, but Criteria Queries have the added benefit of being type-safe and more integrated with the object-oriented model of your application.


18. What is EntityManager?

The EntityManager in Java is an interface that is part of the Java Persistence API (JPA). It is used to create and remove persistent entity instances, to find entities by their primary key, and to query over all entities. The EntityManager API also defines transaction management operations, which can be started, committed, and rolled back.

Some of the key operations that EntityManager provides include:

- persist(Object entity): This method is used to make an instance managed and persistent.
- merge(T entity): This method is used to merge the state of the given entity into the current persistence context.
- remove(Object entity): This method is used to remove the entity instance.
- find(Class<T> entityClass, Object primaryKey): This method is used to find an entity by its primary key.
- createQuery(String qlString): This method is used to create an instance of Query for executing a Java Persistence query language statement.
- createNamedQuery(String name): This method is used to create an instance of Query for executing a named query (a query pre-defined by annotation or XML).
- getTransaction(): This method is used to get the resource-level EntityTransaction object.

The EntityManager is associated with a persistence context, a set of all entities that are managed by the EntityManager instance in a particular transaction. When the EntityManager is closed, the persistence context is also closed and detached from any underlying database connection.

In most common scenarios, you would obtain an EntityManager instance from an EntityManagerFactory, and use it in a try-with-resources statement to ensure that the EntityManager is closed at the end of the transaction.


19. What is SessionFactory and Session?

The SessionFactory and Session are part of the Hibernate framework, which is a popular Object-Relational Mapping (ORM) tool for Java.

- SessionFactory: \
The SessionFactory is a factory class used to get the Session objects. The SessionFactory is a heavyweight object; it is usually created during application start up and kept for later use. You would need one SessionFactory object per database using a separate configuration file. So if you are using multiple databases, then you need multiple SessionFactory objects. The SessionFactory holds second level cache (optional) of data.

- Session: \
The Session object provides an interface between your application and the data stored in a relational database. The session object is lightweight and designed to be instantiated each time an interaction is needed with the database. Persistent objects are saved and retrieved through a Session object. The Session objects are not thread safe, that is why you open a Session for each request in a multithreaded environment.

The Session also provides methods to perform create, read, update and delete operations for a persistent object. It is a single-threaded, short-lived object representing a conversation between the application and the persistent store. It allows you to create query objects to retrieve persistent objects.

Here's a simple way to use a Session in a Hibernate application:
```aidl
// Assuming you have a SessionFactory instance named sessionFactory
try (Session session = sessionFactory.openSession()) {
    // Begin a unit of work
    session.beginTransaction();

    // Do some data persistence operations...
    
    // Commit the current resource transaction, writing any unflushed changes to the database.
    session.getTransaction().commit();
} catch (Exception e) {
    // Handle exception here
}
```

Note that you should always close your Session when you are done to free up resources immediately. In the above example, the try-with-resources statement is used to automatically close the Session.


20. What is Transaction? how to manage your transaction?


In the context of databases, a transaction is a sequence of one or more operations (like insert, update, delete, etc.) which forms a single logical unit of work. A transaction ensures that these operations either complete successfully as a group, or, in case of any error, not at all. This property of transactions is often referred to as "all-or-nothing".

The ACID properties (Atomicity, Consistency, Isolation, and Durability) are key principles of transactions:
- Atomicity: \
Atomicity means that all operations within a transaction are treated as a single, indivisible logical operation. Either all operations are executed successfully, or none of them are. There's no partial execution of a transaction.

- Consistency: \
Consistency ensures that a transaction brings the database from one valid state to another. The database schema should not be violated by any transaction.

- Isolation: \
Isolation ensures that concurrent execution of transactions leaves the database in the same state that would have been obtained if the transactions were executed sequentially.

- Durability: \
Durability guarantees that once a transaction has been committed, it will remain committed even in the case of a system failure.

In Spring, transaction management is typically done via the @Transactional annotation. This annotation can be applied at both method and class level, and it defines the scope of a single database transaction.

Here's a simple example of how to use it:
```aidl
@Service
public class EmployeeService {

    @Autowired
    private EmployeeRepository employeeRepository;

    @Transactional
    public void addTwoEmployees(Employee emp1, Employee emp2){
        employeeRepository.save(emp1);
        employeeRepository.save(emp2);
    }
}
```

In the above code, addTwoEmployees method is annotated with @Transactional. This means the two save operations will be part of a single transaction. If the second save operation fails for any reason, the first save operation will also be rolled back, ensuring data integrity.

Spring's @Transactional annotation is very powerful and provides many options for customization, such as setting the isolation level, specifying a rollback condition, setting a timeout, and more.


21. What is hibernate Caching?

Caching is a mechanism to enhance the performance of a system. It is a buffer memory that lies between the application and the database. Cache memory stores recently used data items to improve system performance by reducing the number of database hits as much as possible.

Hibernate, a popular Object-Relational Mapping (ORM) framework, utilizes a caching technique for reducing the number of database queries, which in turn improves the performance of the application. Hibernate provides two types of caching: First-Level Cache and Second-Level Cache.


- First-Level Cache: \
Hibernate uses a first-level cache by default with every Session object. When a transaction is being executed, and you fetch a record from the database, Hibernate first checks the session-level cache before making a call to the database. If the record is found in the cache, it returns the cached result, reducing the overall time as the database hit is avoided. But this cache is only available per session and is not shared across sessions.

- Second-Level Cache: \
Unlike the first-level cache, the second-level cache is associated with the Session Factory object. It is not enabled by default, and you need to enable it explicitly. The data stored in the second-level cache is available to all sessions and can significantly reduce the number of database hits when multiple sessions need access to the same data.

Hibernate also supports a Query-level cache. It's used to cache the result set of a query. Using the query cache can be useful for queries that run frequently with the same parameters.

Caching can drastically improve the performance of an application. However, it must be noted that it could also lead to stale data (if data is updated in the database directly and cache is not updated) and increased memory usage. Therefore, caching strategies should be chosen wisely based on the application's requirement.


22. What is the difference between first-level cache and second-level cache?
- First-Level Cache: \
  Hibernate uses a first-level cache by default with every Session object. When a transaction is being executed, and you fetch a record from the database, Hibernate first checks the session-level cache before making a call to the database. If the record is found in the cache, it returns the cached result, reducing the overall time as the database hit is avoided. But this cache is only available per session and is not shared across sessions.

- Second-Level Cache: \
  Unlike the first-level cache, the second-level cache is associated with the Session Factory object. It is not enabled by default, and you need to enable it explicitly. The data stored in the second-level cache is available to all sessions and can significantly reduce the number of database hits when multiple sessions need access to the same data.

23. How do you understand @Transactional? (不要clone，要自己抄写并测试 transactional，https://github.com/TAIsRich/tutorial-transaction) \
In MavenProject/transaction

24. Write a simple factory design pattern.\
In MavenProject/DesignPattern/simple_factory_2







