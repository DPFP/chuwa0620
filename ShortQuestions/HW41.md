# HW41
**2.  how do you do the debug?**
1. Add breakpoints
2. Run in Debug mode
3. Trigger the JPA Data code: Perform the actions that involve JPA data interactions. For example, make requests to your JPA repositories to fetch or modify data.
4. Debugger halts at breakpoints: When your code reaches a breakpoint, the debugger will halt execution, and the IntelliJ IDEA Debugger tool window will appear. You can now inspect the state of variables, step through the code, and analyze the JPA interactions.
5. Inspect Variables: While the debugger is paused at a breakpoint, you can hover over variables to see their current values or add them to the Watches section in the Debugger tool window.
6. Step through the code
7. Evaluate expressions
8. Resume and Terminate

**3.  What is DTO, VO, Payload, DO, model?**
- DTO stands for "Data Transfer Object." It is a design pattern used to transfer data between different layers or components of an application, often from the backend to the frontend or between services. The main purpose of a DTO is to encapsulate and aggregate multiple data fields into a single object for more efficient data transfer. DTOs are often used to minimize the amount of data transferred over the network, reducing the overhead and improving performance.
- VO (Value Object):
VO stands for "Value Object." It is a design pattern used to represent an immutable object that holds values. Value objects are usually small, immutable, and have no unique identifier. They are used to model concepts that can be identified by their attributes rather than an ID. Examples of value objects include points in a 2D plane, colors, dates, etc. Value objects are typically used within the domain model of an application.
- Payload:
The term "Payload" refers to the actual data that is being transmitted or carried by a message or a container. It's the meaningful information contained within a message or data structure that is sent between different parts of a system. The payload can be in various formats, such as JSON, XML, or binary data, depending on the communication protocol and application requirements.
- DO (Domain Object):
DO stands for "Domain Object." It represents an object in the domain or business logic of an application. Domain objects encapsulate the behavior and state relevant to the core business logic and rules. They are typically used to represent entities and their relationships within the domain model. Domain objects are an essential part of Domain-Driven Design (DDD) and are responsible for implementing business rules and logic.
- Model:
The term "Model" is a more generic term used to refer to the representation of data and the rules that govern the data's behavior in an application. It encompasses various types of objects, including DTOs, DOs, and Value Objects, that together form the structure and behavior of the application's data. The model can refer to the entire application's data model or just a specific subset, such as the domain model or the view model (in the context of Model-View-Controller architecture).

**4.  What is @JsonProperty("description_yyds")**
With the @JsonProperty("description_yyds") annotation, Jackson will use the specified JSON property name "description_yyds" for the specified field when serializing the object to JSON and when deserializing JSON back to the Java object.

**6.  What is spring-boot-stater?**
It is a set of pre-configured dependencies that enable developers to quickly and easily add specific features or functionality to their Spring Boot applications. Spring Boot starters are designed to simplify the dependency management process and provide a streamlined way of setting up various components in your application.

Each starter is tailored for a specific purpose, and they come with all the necessary dependencies, configurations, and auto-configuration classes to get that particular feature up and running in your project with minimal effort.

The spring-boot-starter-web includes the following key dependencies:
- Spring MVC (spring-webmvc): This provides the framework for building web applications using the Model-View-Controller (MVC) pattern.
- Embedded Tomcat (spring-boot-starter-tomcat): This is an embedded servlet container, which allows you to run your Spring Boot application without deploying it to a standalone server.
- Spring Web (spring-web): This provides essential web-related features and utilities.
- Other transitive dependencies: The starter may also include other dependencies that are required for the main components to function correctly.

Some other examples of Spring Boot starters include:
- spring-boot-starter-data-jpa: Includes Spring Data JPA and the necessary database driver to work with relational databases.
- spring-boot-starter-security: Provides Spring Security for securing your web application.
- spring-boot-starter-test: Includes dependencies for testing your Spring Boot application.

**7. do you know  @RequestMapping(value = "/users", method = RequestMethod.POST) ? could you list CRUD by this style?**
The annotation is applied to a method that handles HTTP POST requests sent to the "/users" endpoint.
```
@RequestMapping(value = "/users", method = RequestMethod.POST)
@RequestMapping(value = "/users", method = RequestMethod.GET)
@RequestMapping(value = "/users/{id}", method = RequestMethod.PUT)
@RequestMapping(value = "/users/{id}", method = RequestMethod.DELETE)
```

**8. What is ResponseEntity? why do we need it?**
ResponseEntity is a class provided by the Spring Framework, specifically in Spring Web, which represents the entire HTTP response sent back to the client in a web application. It encapsulates the HTTP status code, headers, and response body.

When building RESTful web services or APIs using Spring, you often need to return data to clients in the form of an HTTP response. ResponseEntity provides a convenient and flexible way to construct these responses.

Here's why we need ResponseEntity:
1. HTTP Status and Headers: ResponseEntity allows you to set the HTTP status code and headers of the response. This is crucial for indicating the success or failure of the request and providing additional metadata to the client.
2. Response Body: ResponseEntity allows you to include the response data in the body of the response. You can return different types of data, such as JSON, XML, or even plain text.
3. Flexibility: ResponseEntity is generic, which means you can define the type of data you want to send as a response. This gives you the flexibility to handle different types of responses based on your application's requirements.
4. Error Handling: When dealing with errors or exceptions in your application, you can customize the HTTP status code and response body to provide meaningful error messages to the client using ResponseEntity.

**9.  What is ResultSet in jdbc? and describe the flow how to get data using JDBC**
In JDBC (Java Database Connectivity), a ResultSet is an interface that represents the result of a database query. It is used to retrieve data from a database after executing an SQL statement, typically a SELECT query. The ResultSet object maintains a cursor that points to the current row of data, and you can use methods provided by the ResultSet interface to navigate through the results and extract data from each row.

Here's a general flow of how to get data using JDBC:
1. Import JDBC Packages: Make sure you have the necessary JDBC library (usually provided by your database vendor) and import the required JDBC packages in your Java code.
2. Load the Driver: Register the JDBC driver by loading the appropriate driver class using Class.forName() method. For example, if you are using MySQL, you would load the driver like this: Class.forName("com.mysql.cj.jdbc.Driver");.
3. Establish Connection: Create a database connection using DriverManager.getConnection(), providing the database URL, username, and password as parameters.
4. Create Statement: Create a Statement or PreparedStatement object using the database connection. The Statement is used to execute SQL queries, and PreparedStatement allows parameterized queries for better security and performance.
5. Execute Query: Use the Statement or PreparedStatement object to execute the SQL query. For SELECT queries, use executeQuery() method, which returns a ResultSet containing the query results.
6. Process Results: Use methods like next() to move the cursor to the next row and getXXX() methods (e.g., getString(), getInt(), getDate(), etc.) to retrieve data from the current row. These methods take the column index or column name as parameters.
7. Process Data: Loop through the ResultSet to process all the rows and extract the required data. You can use a while loop with the next() method to move through each row until there are no more rows left.
8. Close Resources: After you are done processing the ResultSet, close all the resources in the reverse order of their creation - close the ResultSet, close the Statement/PreparedStatement, and close the Connection.
9. Exception Handling: Always handle any potential exceptions that might occur during the database operations.

**10. What is the ORM framework?**
ORM stands for Object-Relational Mapping. It is a programming technique used in software development to facilitate the interaction between a relational database and the application's object-oriented code. The primary goal of an ORM framework is to bridge the gap between the relational database model, where data is stored in tables with rows and columns, and the object-oriented programming model, where data is represented as objects with attributes and methods.

**12. What is the serialization and desrialization?**
Serialization is the process of converting an object's state into a stream of bytes so that it can be easily stored or transmitted. The serialized data contains all the information about the object, including its instance variables and the class information.

Deserialization is the reverse process of serialization. It involves converting the serialized data back into an object, reconstructing its state as it was when it was serialized. 

**13. use stream api to get the average of the array [20, 3, 78, 9, 6, 53, 73, 99, 24, 32]**
```
double average = Arrays.stream(array).average().orElse(Double.NaN);
```