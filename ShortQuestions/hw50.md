# HW50

### 2.Document the microservice architeture and components/tools/dependencies
Microservice architecture is a design pattern where an application is created as a collection of small, independent, and loosely coupled services. Each microservice is responsible for a specific piece of functionality and can be developed, deployed, and scaled independently. Below is a documentation of the typical components, tools, and dependencies that can be found in a microservice architecture.

Components of Microservice Architecture:
1.1 Services
Microservices: Individual functional modules that are responsible for specific parts of the business logic.
API Gateway: A server that is the single entry point into the system, responsible for requests routing, composition, and other functions.
1.2 Databases
Database-per-Service: Each microservice can have its dedicated database to ensure loose coupling.
Shared Database: Some architectures may use a shared database, but it's less common as it can create dependencies between services.
1.3 Communication
Synchronous Communication: Often using HTTP/REST or gRPC.
Asynchronous Communication: Often using Message Queuing technologies like Kafka, RabbitMQ, etc.

Tools
2.1 Development
Programming Languages: Java, C#, Python, Go, etc.
Frameworks: Spring Boot, Flask, Django, etc.
Build Tools: Maven, Gradle, Jenkins, etc.
2.2 Deployment
Containerization: Docker.
Orchestration: Kubernetes, Docker Swarm.
Continuous Integration/Continuous Deployment (CI/CD): Jenkins, GitLab CI, Travis CI, etc.
2.3 Monitoring and Logging
Monitoring: Prometheus, Grafana, Datadog, etc.
Logging: Logstash, Elasticsearch, Kibana (ELK stack), Fluentd, etc.
2.4 Service Discovery and Load Balancing
Service Discovery: Eureka, Consul, etc.
Load Balancing: Nginx, HAProxy, AWS ELB, etc.

Dependencies
Operating Systems: Compatible with Linux, Windows, macOS, etc.
Cloud Providers: Can be hosted on AWS, Azure, Google Cloud, etc.
Libraries and SDKs: Specific to programming languages and frameworks used.

### 3.What are Resilience patterns? What is circuit breaker?
Resilience patterns are design strategies used in software systems to enable them to cope with unexpected failures or changes in the system. These patterns ensure that the system continues to function in the face of adversity, providing a degree of fault tolerance, flexibility, and responsiveness. 
The Circuit Breaker pattern is particularly interesting and widely used among these resilience patterns. It is inspired by the electrical circuit breaker that cuts off electrical flow if the current reaches a threshold that may be harmful.

### 4.Read this article, then list the important questions, then write your answers
What are the benefits and drawbacks of Microservices?
benefit:
Self-contained, and independent deployment module. 
Independently managed services.   
In order to improve performance, the demand service can be deployed on multiple servers.   
It is easier to test and has fewer dependencies.  
A greater degree of scalability and agility.   
drawback:
Due to the complexity of the architecture, testing and monitoring are more difficult. 

### 5.how to do load balance in microservice? Write a long Summary by yourself.
Round Robin
In this simple method, requests are distributed evenly across all service instances. Once a request is sent to a specific instance, the next request is sent to the following instance in the list.
Least Connections
This strategy directs incoming requests to the service instance with the fewest active connections, minimizing the risk of overloading a single instance.
IP Hashing
Using the client's IP address to determine the service instance ensures that a particular client always connects to the same instance, which can be helpful for session persistence.

### 6.How to do service discovery?
Client-Side Service Discovery
In this pattern, clients query a service registry to find out the location of service instances and make a direct call. This offers more control and flexibility but may put extra burden on the client.
Server-Side Service Discovery
Here, a load balancer or a gateway queries the service registry and routes the client request to an appropriate service instance. This abstracts the discovery logic from the client.

### 7.What are the major components of Kafka?
Producer, customer, broker, topic, partition, zookeeper, controller, replicas, Kafka connect, Kafka Streams.

### 8.What do you mean by a Partition in Kafka?
In Apache Kafka, a partition is a fundamental unit of parallelism and scalability. It is a core concept and plays a vital role in Kafka's distributed architecture. 

### 9.What do you mean by zookeeper in Kafka and what are its uses?
Apache ZooKeeper is a critical component in the Kafka ecosystem, acting as a distributed coordination service that helps manage the Kafka brokers.

### 10.Can we use Kafka without Zookeeper?
Yes, starting with Kafka 2.8.0, it is possible to run Kafka without ZooKeeper by using Kafka's KRaft (Kafka Raft) mode.

### 11.Explain the concept of Leader and Follower in Kafka
Leader Replica
For each partition, one replica is designated as the Leader. The Leader replica handles all reads and writes for that partition. When a producer wants to write a message to a partition, or a consumer wants to read from a partition, the corresponding requests are handled by the Leader
Follower Replicas
The other replicas for a partition are known as Followers. Followers do not serve client requests; instead, they replicate the data from the Leader. They continuously fetch messages from the Leader to stay synchronized.

### 12.Why is Topic Replication important in Kafka? What do you mean by ISR in Kafka?
Topic replication is a vital aspect of Apache Kafka's architecture, providing fault tolerance, high availability, and durability. ISR, or In-Sync Replicas, is a concept closely tied to topic replication. 
The ISR includes the leader replica and all follower replicas that have not lagged behind the leader by more than a configurable number of messages. They are considered "in sync" with the leader.

### 13.What do you understand about a consumer group in Kafka?
A consumer group is a fundamental concept in Apache Kafka that plays a key role in achieving scalability and flexibility in message consumption. It's a way to allow a pool of processes to divide the work of consuming and processing records from one or more topics. 

### 14.How do you start a Kafka server?
Start ZooKeeper
Configure Kafka Broker
Start Kafka Broker

### 15.Tell me about some of the real-world usages of Apache Kafka.
real-time processing and monitoring of financial transactions，integration of different healthcare systems，connect IoT devices across manufacturing plants for real-time monitoring and predictive maintenance

### 16.Describe partitioning key in Kafka
A partitioning key is used to determine which specific partition a message will be sent to within a topic.

### 17.What is the purpose of partitions in Kafka?
Multiple consumers in a consumer group can read different partitions of the same topic simultaneously, allowing for parallel processing of messages.

### 18.Differentiate between Rabbitmq and Kafka.
RabbitMQ: Focuses on flexible routing and traditional messaging patterns. Queues are central, and messages are pushed to consumers.
Kafka: Built around the log-structured storage model, where messages are appended to logs. Consumers pull messages from topics at their own pace, allowing for replayability.

### 19.What are the guarantees that Kafka provides?
Ordering Guarantee，Durability Guarantee，Fault Tolerance Guarantee，Scalability Guarantee，Consistency Guarantee，Delivery Semantics Guarantee.

### 20.What do you mean by an unbalanced cluster in Kafka? How can you balance it?
In Kafka, an "unbalanced cluster" refers to a state where the distribution of partition replicas across the brokers is uneven. This imbalance can lead to performance bottlenecks, inefficient resource utilization, and can impact the cluster's ability to tolerate broker failures.

### 21.In your recent project, are you a producer or consumer or both?
producer

### 25.What is offset?
unique identifier for a record within a partition. It represents the position of the message within the partition and is used to keep track of the messages that have been consumed.

